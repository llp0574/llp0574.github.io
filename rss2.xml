<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>llp的程序猿之路</title>
    <link>http://llp0574.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>llp的程序猿之路走得磕磕绊绊</description>
    <pubDate>Thu, 01 Dec 2016 10:30:09 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Webpack 2 入门教程</title>
      <link>http://llp0574.github.io/2016/11/29/getting-started-with-webpack2/</link>
      <guid>http://llp0574.github.io/2016/11/29/getting-started-with-webpack2/</guid>
      <pubDate>Tue, 29 Nov 2016 14:57:55 GMT</pubDate>
      <description>
      
        &lt;p&gt;本文写于 Webpack 2 正式发布之前（完善文档阶段），不仅是 Webpack 2 的入门教程，也介绍了 Webpack 是什么。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://blog.madewithenvy.com
      
      </description>
      
      <content:encoded><![CDATA[<p>本文写于 Webpack 2 正式发布之前（完善文档阶段），不仅是 Webpack 2 的入门教程，也介绍了 Webpack 是什么。</p>
<blockquote>
<ul>
<li>原文地址：<a href="https://blog.madewithenvy.com/getting-started-with-webpack-2-ed2b86c68783#.7a93d61z6" target="_blank" rel="external">Getting Started with Webpack 2
</a></li>
<li>原文作者：<a href="https://blog.madewithenvy.com/@an_ennui?source=post_header_lockup" target="_blank" rel="external">Drew Powers</a></li>
<li>译者：<a href="https://llp0574.github.io/">linpu.li</a></li>
</ul>
</blockquote>
<p>Webpack 2 将在其文档完成之后正式发布。但这并不意味着不可以开始使用它，如果你知道怎么配置的话。</p>
<h3 id="什么是-Webpack？"><a href="#什么是-Webpack？" class="headerlink" title="什么是 Webpack？"></a>什么是 Webpack？</h3><p>简单来说，Webpack 就是一个针对 JavaScript 代码的模块打包工具。但是自发布以来，它演变成了一个针对所有前端代码的管理工具（不管是其本身有意还是社区的意愿）。</p>
<p><img src="/img/1.png" alt=""></p>
<p>旧的任务运行工具处理方式：HTML、CSS 和 JavaScript 都是分离的。必须分别对每一项进行管理，并且还要确保所有东西正确地部署到生产环境。</p>
<p>像 <strong>Gulp</strong> 这样的任务运行工具可以操作很多不同的预处理器和编译器，但是在所有情况下，它都需要接收一个源码<strong>输入</strong>并将其处理成一个编译好的<strong>输出</strong>。然而，它是在不关心整个系统的情况下逐个去处理的。这就是开发者的负担了：检查任务运行工具有无遗漏的地方，并为所有改动的部分找到正确的方式，将它们在生产环境上协调一致。</p>
<p>Webpack 通过一个大胆的询问试图减轻开发者的负担：<strong>如果开发过程的某个部分可以自己管理依赖会怎么样？如果我们可以以这样一种方式来简单地写代码：构建过程仅基于最后所需要的东西来管理它自己，会怎么样？</strong></p>
<p><img src="/img/2.png" alt=""></p>
<p>Webpack 处理方式：如果是 Webpack 知道的代码，那么它就只会打包实际在生产环境当中使用的部分。</p>
<p>如果你是过去几年里 Web 社区当中的一员，那么你肯定已经知道首选解决问题的方法：<strong>使用 JavaScript 构建</strong>。所以 Webpack 试图通过用 JavaScript 传递依赖来使构建过程变得更加容易。但是它设计的精妙之处并不在于简单的代码管理部分，而在于它的管理层面是百分百有效的 JavaScript（还有 Node 特性）。Webpack 使你有机会写出一些对整体系统有更好感知的 JavaScript 代码。</p>
<p>换句话说：<strong>你不是为了 Webpack 写代码，而是为了你的项目写代码。</strong>而且 Webpack 在保持进步（当然包括某些配置）。</p>
<p>总而言之，如果你曾经挣扎于下面这些情况中的其中之一：</p>
<ul>
<li>不小心将一些不需要的样式表或者 JS 库引入生产环境，导致项目体积变大</li>
<li>遇到作用域问题 - 不管是来自 CSS 还是 JavaScript</li>
<li>不停寻找一个好的系统好让你可以在 JavaScript 代码里使用 Node 或 Bower 的模块，或者依赖一系列疯狂的后端配置来正确地使用那些模块</li>
<li>需要优化资源分发机制却又担心会破坏掉某些东西</li>
</ul>
<p>…那么你就可以受益于 Webpack 了。它通过让 JavaScript 取代开发者的大脑来关心依赖和加载顺序，轻松地解决了上面这些问题。最好的部分是什么？Webpack 甚至可以在服务端无缝运行，这意味着你仍然可以使用 Webpack 来构建<a href="https://www.smashingmagazine.com/2009/04/progressive-enhancement-what-it-is-and-how-to-use-it/" target="_blank" rel="external">渐进式增强</a>的网站。</p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>在这篇教程里我们将使用 <a href="https://yarnpkg.com/" target="_blank" rel="external">Yarn</a>（<code>brew install yarn</code>）来替代 <code>npm</code>，但这完全取决于你自己，它们做的是同样的事情。打开到项目文件夹，在命令行窗口运行下面的命令添加 Webpack 2 到全局包和本地项目里：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yarn global add webpack@2.1.0-beta.25 webpack-dev-server@2.1.0-beta.10</div><div class="line">yarn add --dev webpack@2.1.0-beta.25 webpack-dev-server@2.1.0-beta.10</div></pre></td></tr></table></figure>
<p>然后在根目录新建一个 <code>webpack.config.js</code> 文件用来声明 Webpack 的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">const webpack = require(&quot;webpack&quot;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  context: __dirname + &quot;/src&quot;,</div><div class="line">  entry: &#123;</div><div class="line">    app: &quot;./app.js&quot;,</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    path: __dirname + &quot;/dist&quot;,</div><div class="line">    filename: &quot;[name].bundle.js&quot;,</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注意：<strong><code>__dirname</code>指的是根目录。</strong></p>
<p>还记得 Webpack “知道”项目里发生了什么吗？它是通过读取你的代码知道的（不用担心，它签署了一份保密协议）。Webpack 基本做了下面这些事情：</p>
<ol>
<li>从 <code>context</code> 对应的文件夹开始…</li>
<li>…寻找 <code>entry</code> 里所有的文件名…</li>
<li>…然后读取它们的内容。在解析代码时，每一个通过 <code>import</code>（ES6） 或 <code>require()</code>（Node） 引入的依赖都会被打包到最终的构建结果当中。它会接着搜索<strong>那些</strong>依赖，以及那些依赖的依赖，直到“依赖树”的叶子节点 — 只打包它所需要的依赖，没有其他的东西。</li>
<li>接着，Webpack 将所有东西打包到 <code>output.path</code> 对应的文件夹里，使用 <code>output.filename</code> 对应的命名模板来命名（<code>[name]</code> 被 <code>entry</code> 里的对象键值所替代）</li>
</ol>
<p>所以如果 <code>src/app.js</code> 文件看起来像下面这样的话（假设提前运行了 <code>yarn add --dev moment</code>）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line">import moment from &apos;moment&apos;;</div><div class="line">var rightNow = moment().format(&apos;MMMM Do YYYY, h:mm:ss a&apos;);</div><div class="line">console.log( rightNow );</div><div class="line">// &quot;October 23rd 2016, 9:30:24 pm&quot;</div></pre></td></tr></table></figure>
<p>接着运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack -p</div></pre></td></tr></table></figure>
<p>注意：<strong><code>p</code> 标记表示“生产（production）”模式并且会压缩或丑化（uglify/minify）输出。</strong></p>
<p>然后它将输出一个 <code>dist/app.bundle.js</code> 文件，作用就是打印出当前日期和时间到控制台。注意到 Webpack 自动知道了 <code>&#39;moment&#39;</code> 指的是什么（但如果已经有一个 <code>moment.js</code> 在你的目录当中，那么 Webpack 默认就会优先使用这个而不是 <code>moment</code> 的 Node 模块）。</p>
<h3 id="处理多个文件"><a href="#处理多个文件" class="headerlink" title="处理多个文件"></a>处理多个文件</h3><p>你只需要通过修改 <code>entry</code> 对象就可以指定任意数量所期望的 entry 或 output 点。</p>
<h4 id="多个文件，打包在一起"><a href="#多个文件，打包在一起" class="headerlink" title="多个文件，打包在一起"></a>多个文件，打包在一起</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">const webpack = require(&quot;webpack&quot;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  context: __dirname + &quot;/src&quot;,</div><div class="line">  entry: &#123;</div><div class="line">    app: [&quot;./home.js&quot;, &quot;./events.js&quot;, &quot;./vendor.js&quot;],</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    path: __dirname + &quot;/dist&quot;,</div><div class="line">    filename: &quot;[name].bundle.js&quot;,</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>所有文件会按数组顺序一起打包到 <code>dist/app.bundle.js</code> 一个文件当中。</p>
<h4 id="多个文件，多个输出"><a href="#多个文件，多个输出" class="headerlink" title="多个文件，多个输出"></a>多个文件，多个输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">const webpack = require(&quot;webpack&quot;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  context: __dirname + &quot;/src&quot;,</div><div class="line">  entry: &#123;</div><div class="line">    home: &quot;./home.js&quot;,</div><div class="line">    events: &quot;./events.js&quot;,</div><div class="line">    contact: &quot;./contact.js&quot;,</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    path: __dirname + &quot;/dist&quot;,</div><div class="line">    filename: &quot;[name].bundle.js&quot;,</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>另外，你还可以选择打包成多个 JS 文件来将应用拆解成几个部分。像上面这样做就可以打包成三个文件：<code>dist/home.bundle.js</code>、<code>dist/events.bundle.js</code> 和 <code>dist/contact.bundle.js</code>。</p>
<h4 id="进阶自动打包"><a href="#进阶自动打包" class="headerlink" title="进阶自动打包"></a>进阶自动打包</h4><p>如果你正在将应用拆解，打包成多个 <code>output</code> 的话（如果应用的某部分有大量不需要提前加载的 JS 的话，这样做会很有用），那么在这些文件里就有可能出现重复的代码，因为在解决依赖问题的时候它们是互相不干预的。幸好，Webpack 有一个内建插件 <strong>CommonsChunk</strong> 来处理这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // …</div><div class="line">  plugins: [</div><div class="line">    new webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">      name: &quot;commons&quot;,</div><div class="line">      filename: &quot;commons.js&quot;,</div><div class="line">      minChunks: 2,</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">// …</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>现在，在 <code>output</code> 的文件里，如果有任意模块加载了两次或更多（通过 <code>minChunks</code> 设置该值），它就会被打包进一个叫 <code>commons.js</code> 的文件里，后面你就可以在客户端缓存这个文件了。当然，这肯定会造成一次额外的请求，但是却避免了客户端多次下载相同库的问题。所以在很多场景下，这都是提升速度的举措。</p>
<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>实际上 Webpack 有它自己的开发服务器，所以无论你正在开发一个静态网站，或者只是正在原型化前端阶段，这个服务器都是完美可用的。想要运行它，只需要在 <code>webpack.config.js</code> 里添加一个 <code>devServer</code> 对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  context: __dirname + &quot;/src&quot;,</div><div class="line">  entry: &#123;</div><div class="line">    app: &quot;./app.js&quot;,</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    filename: &quot;[name].bundle.js&quot;,</div><div class="line">    path: __dirname + &quot;/dist/assets&quot;,</div><div class="line">    publicPath: &quot;/assets&quot;,            // New</div><div class="line">  &#125;,</div><div class="line">  devServer: &#123;</div><div class="line">    contentBase: __dirname + &quot;/src&quot;,  // New</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>现在新建一个 <code>src/index.html</code> 文件，加入下面这行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;/assets/app.bundle.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>然后在命令行中，运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack-dev-server</div></pre></td></tr></table></figure>
<p>服务器现在就运行在了 <code>localhost:8080</code> 上。注意 script 标签中的 <code>/assets</code> 对应的是 <code>output.publicPath</code> 的值 - 可以随便填成你想要的命名（如果需要一个 CDN，这就很有用了）。</p>
<p>当你更改 JavaScript 代码的时候，Webpack 就会实时更新页面而无需手动刷新浏览器。但是，<strong>任何对 <code>webpack.config.js</code> 的更改都需要重启服务器</strong>才可以生效。</p>
<h3 id="全局可访问方法"><a href="#全局可访问方法" class="headerlink" title="全局可访问方法"></a>全局可访问方法</h3><p>需要在全局命名空间里使用某些自己的方法吗？只需简单地在 <code>webpack.config.js</code> 里设置 <code>output.library</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  output: &#123;</div><div class="line">    library: &apos;myClassName&apos;,</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>…这样就会把打包结果绑定到一个 <code>window.myClassName</code> 实例上。所以使用这种命名作用域，就可以调用 entry 点里面的方法了（可以阅读<a href="https://webpack.js.org/concepts/output/#output-library" target="_blank" rel="external">文档</a>获取更多关于这个配置的信息）。</p>
<h3 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h3><p>目前为止，我们所讲到的都是关于 JavaScript 代码的使用。从 JavaScript 代码开始是非常重要的，因为<strong>这是 Webpack 唯一使用的语言</strong>。我们可以处理任何文件类型，只要将它们传进 JavaScript 代码中。这个功能用 <strong>Loaders</strong> 来实现。</p>
<p>一个 loader 可以指向一个像 Sass 的预处理器，或者像 Babel 的编译器。在 NPM 中，它们通常是像 <code>sass-loader</code> 或 <code>babel-loader</code> 这样命名为 <code>*-loader</code>。</p>
<h4 id="Babel-ES6"><a href="#Babel-ES6" class="headerlink" title="Babel + ES6"></a>Babel + ES6</h4><p>如果我们想要在项目中通过 Babel 来使用 ES6，首先要在本地正确地安装一些 loader：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yarn add --dev babel-loader babel-core babel-preset-es2015</div></pre></td></tr></table></figure>
<p>…然后把它们添加进 <code>webpack.config.js</code> 好让 Webpack 知道哪里使用它们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // …</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.js$/,</div><div class="line">        use: [&#123;</div><div class="line">          loader: &quot;babel-loader&quot;,</div><div class="line">          options: &#123; presets: [&quot;es2015&quot;] &#125;</div><div class="line">        &#125;],</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      // Loaders for other file types can go here</div><div class="line">    ],</div><div class="line">  &#125;,</div><div class="line">  // …</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>一个给 Webpack 1 用户的提示：Loaders 的核心概念仍然是一样的，但语法上做了改进。在他们完成文档之前这可能不是确切的首选语法。</p>
<p>这样做就可以为 <code>/\.js$/</code> 正则表达式寻找以 <code>.js</code> 结尾的文件，最后通过 Babel 编译加载。Webpack 依赖正则表达式给予你完整的控制 - 但它不会限制你的文件后缀，或者假设你的代码必须以某种特定形式组织起来。举个例子：也许你的 <code>/my_legacy_code/</code> 文件夹里的代码不是用 ES6 写的，那么你就可以把上面的 <code>test</code> 修改为 <code>/^((?!my_legacy_code).)*\.js$/</code>，这样就可以绕过这个文件夹，其余文件用 Babel 编译。</p>
<h4 id="CSS-Style-Loader"><a href="#CSS-Style-Loader" class="headerlink" title="CSS + Style Loader"></a>CSS + Style Loader</h4><p>如果我们只想加载应用需要的 CSS，也可以那么做。假设有一个 <code>index.js</code> 文件，在里面引入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import styles from &apos;./assets/stylesheets/application.css&apos;;</div></pre></td></tr></table></figure>
<p>就会得到一个错误：<code>You may need an appropriate loader to handle this file type</code>。记住 Webpack 只能读取 JavaScript，所以我们必须安装正确的 loader：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yarn add --dev css-loader style-loader</div></pre></td></tr></table></figure>
<p>然后在 <code>webpack.config.js</code> 里添加一个规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // …</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.css$/,</div><div class="line">        use: [&quot;style-loader&quot;, &quot;css-loader&quot;],</div><div class="line">      &#125;,</div><div class="line">      // …</div><div class="line">    ],</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这些 loader 会以数组逆序运行。这意味着 <code>css-loader</code> 会在 <code>style-loader</code> 之前运行。</p>
<p>你可能注意到甚至在生产构建的结果中，也把 CSS 打包进了 JavaScript 里面，并且 <code>style-loader</code> 手动地将样式写进了 <code>&lt;head&gt;</code> 中。乍一看这可能有点奇怪，但当你考虑足够多的时候就会慢慢发现这其实是有道理的。你保存了一个头部请求（在某些连接上节省宝贵的时间），并且如果你用 JavaScript 来加载 DOM，这么做基本上就消除了它自身的<a href="https://en.wikipedia.org/wiki/Flash_of_unstyled_content" target="_blank" rel="external">无样式闪屏</a>问题。</p>
<p>还注意到 Webpack 已经通过把所有文件打包成一个从而自动解决了所有的 <code>@import</code> 查询问题（比起依赖 CSS 默认的引入导致不必要的头部请求和缓慢的资源加载，这么做显然更好）。</p>
<p>从 JS 里加载 CSS 相当爽，<strong>因为你可以用一种强有力的新方式去模块化 CSS 代码了</strong>。假设你只通过 <code>button.js</code> 加载了 <code>button.css</code>，这就意味着如果 <code>button.js</code> 没有实际用到的话，它的 CSS 也不会打包进我们的生产构建结果。如果你坚持使用像 SMACSS 或者 BEM 那样的面向组件的 CSS，就会知道把 CSS 和 HTML + JavaScript 代码放更近的价值了。</p>
<h4 id="CSS-Node-modules"><a href="#CSS-Node-modules" class="headerlink" title="CSS + Node modules"></a>CSS + Node modules</h4><p>我们可以在 Webpack 里用 Node 的 <code>~</code> 前缀去引入 Node Modules。假设我们提前运行了 <code>yarn add normalize.css</code>，就可以这么用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@import &quot;~normalize.css&quot;;</div></pre></td></tr></table></figure>
<p>这样就可以全面使用 NPM 来管理第三方样式库（版本及其他）而对我们而言就无需复制粘贴了。更进一步的是，Webpack 打包 CSS 比使用默认的 CSS 引入有着显而易见的优势，让客户端远离不必要的头部请求和缓慢的资源加载。</p>
<p><strong>更新：这个部分和下面的部分为了更准确都进行了更新，不用再困扰于使用 CSS Modules 去简单地引入 Node Modules 了。感谢 <a href="https://medium.com/u/901a038e32e5" target="_blank" rel="external">Albert Fernández</a> 的帮助！</strong></p>
<h4 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h4><p>你可能已经听说过 <a href="https://github.com/css-modules/css-modules" target="_blank" rel="external">CSS Modules</a>，它将 CSS（Cascading Style Sheets）里的 C（Cascading）给提出来了。它只在用 JavaScript 构建 DOM 的时候使用有最佳效果，但本质上来说，它巧妙地将 CSS 在加载它的 JavaScript 里作用域化了（<a href="https://github.com/css-modules/css-modules" target="_blank" rel="external">点击这个链接学习更多相关知识</a>）。如果你计划使用它，CSS Modules 对应的 loader 是 <code>css-loader</code>（<code>yarn add --dev css-loader</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // …</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.css$/,</div><div class="line">        use: [</div><div class="line">          &quot;style-loader&quot;,</div><div class="line">          &#123; loader: &quot;css-loader&quot;, options: &#123; modules: true &#125; &#125;</div><div class="line">        ],</div><div class="line">      &#125;,</div><div class="line">      // …</div><div class="line">    ],</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>注意：对于 <code>css-loader</code> 我们使用了展开的对象语法来为它添加配置。你可以写简单的字符串代表使用默认配置，<code>style-loader</code> 就还是这么做的。</strong></p>
<hr>
<p>值得注意的是实际上在使用 CSS Modules 引入 Node Modules 的时候可以去掉 <code>~</code> 符号（如 <code>@import &quot;normalize.css&quot;;</code>）。但是，当 <code>@import</code> 你自己的 CSS 时可能会遇到错误。如果你得到了 “can’t find ___” 这样的错误，尝试添加一个 <code>resolve</code> 对象到 <code>webpack.config.js</code> 里，好让 Webpack 更好地理解你预期的模块顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const path = require(&quot;path&quot;);</div><div class="line">module.exports = &#123;</div><div class="line">  //…</div><div class="line">  resolve: &#123;</div><div class="line">    modules: [path.resolve(__dirname, &quot;src&quot;), &quot;node_modules&quot;]</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>首先指定了我们自己的源文件目录，然后是 <code>node_modules</code>。这样子 Webpack 解决起来就会处理得更好一些，按照那个顺序先找我们的源文件目录，然后是已安装的 Node Modules（分别用你自己的源码和 Node Modules 目录替换其中的 <code>src</code> 和 <code>node_modules</code>）。</p>
<h4 id="Sass"><a href="#Sass" class="headerlink" title="Sass"></a>Sass</h4><p>想用 Sass？没问题，安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yarn add --dev sass-loader node-sass</div></pre></td></tr></table></figure>
<p>然后添加另一条规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  // …</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.(sass|scss)$/,</div><div class="line">        use: [</div><div class="line">          &quot;style-loader&quot;,</div><div class="line">          &quot;css-loader&quot;,</div><div class="line">          &quot;sass-loader&quot;,</div><div class="line">        ]</div><div class="line">      &#125;</div><div class="line">      // …</div><div class="line">    ],</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>接下来当 JavaScript 调用 <code>import</code> 引入一个 <code>.scss</code> 或 <code>.sass</code> 文件时，Webpack 就会做它该做的事情了。</p>
<h4 id="分开打包-CSS"><a href="#分开打包-CSS" class="headerlink" title="分开打包 CSS"></a>分开打包 CSS</h4><p>或许你正在处理渐进式增强的网站，又或许因为其他的原因你需要一个分离的 CSS 文件。我们可以简单地实现，只需要在配置里用 <code>extract-text-webpack-plugin</code> 替换掉 <code>style-loader</code>，而无需改变其他任何代码。以 <code>app.js</code> 文件为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import styles from &apos;./assets/stylesheets/application.css&apos;;</div></pre></td></tr></table></figure>
<p>本地安装插件（我们需要这个的测试版本，2016年10月发布）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yarn add --dev extract-text-webpack-plugin@2.0.0-beta.4</div></pre></td></tr></table></figure>
<p>添加到 <code>webpack.config.js</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);</div><div class="line">module.exports = &#123;</div><div class="line">  // …</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.css$/,</div><div class="line">        loader:  ExtractTextPlugin.extract(&#123;</div><div class="line">          loader: &apos;css-loader?importLoaders=1&apos;,</div><div class="line">        &#125;),</div><div class="line">      &#125;,</div><div class="line"></div><div class="line">      // …</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    new ExtractTextPlugin(&#123;</div><div class="line">      filename: &quot;[name].bundle.css&quot;,</div><div class="line">      allChunks: true,</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>现在运行 <code>webpack -p</code> 的时候就可以看到一个 <code>app.bundle.css</code> 文件出现在 <code>output</code> 目录里了。像往常一样简单地添加一个 <code>&lt;link&gt;</code> 标签到 HTML 文件里就可以了。</p>
<h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><p>你可能已经猜到，Webpack 还有一个 <code>[html-loader](https://github.com/webpack/html-loader)</code> <a href="https://github.com/webpack/html-loader" target="_blank" rel="external">插件</a>。但是，当我们开始用 JavaScript 加载 HTML 的时候，这其实是一个可以分支成不同方法的地方，而且我想不到一个单独的简单示例可以覆盖所有下一步操作的可能性。通常，你可能会在用 <a href="https://facebook.github.io/react/" target="_blank" rel="external">React</a>、<a href="https://angularjs.org/" target="_blank" rel="external">Angular</a>、<a href="http://vuejs.org/" target="_blank" rel="external">Vue</a> 或者 <a href="http://emberjs.com/" target="_blank" rel="external">Ember</a> 构建的大型系统中加载诸如 <a href="https://jsx.github.io/" target="_blank" rel="external">JSX</a>、<a href="https://github.com/janl/mustache.js/" target="_blank" rel="external">Mustache</a> 或者 <a href="http://handlebarsjs.com/" target="_blank" rel="external">Handlebars</a> 这样偏向 JavaScript 的模板 HTML；或者你可能使用一个像 <a href="https://github.com/pugjs/pug-loader" target="_blank" rel="external">Pug</a>（以前的 Jade）或者 <a href="https://github.com/AlexanderPavlenko/haml-loader" target="_blank" rel="external">Haml</a> 这样的 HTML 预处理器；或者你可能只是想简单地将源文件目录里的 HTML 复制到构建结果目录里。不管你想做什么，我没办法假设。</p>
<p>所以我准备在此结束本教程：你可以用 Webpack 加载 HTML，但这一点你必须自己根据你的架构做出决策，不管是我还是 Webpack 都没办法帮到你。不过使用上述例子作为参考并在 NPM 上找到正确的 loader 应该足够让你继续下去了。</p>
<h3 id="从模块角度思考"><a href="#从模块角度思考" class="headerlink" title="从模块角度思考"></a>从模块角度思考</h3><p>为了最大程度发挥 Webpack 的作用，你不得不从模块的角度去思考（小、可复用、自包含进程），一件件事情慢慢去做好。这意味着下面这样的东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">└── js/</div><div class="line">    └── application.js   // 300KB of spaghetti code</div></pre></td></tr></table></figure>
<p>把它变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">└── js/</div><div class="line">    ├── components/</div><div class="line">    │   ├── button.js</div><div class="line">    │   ├── calendar.js</div><div class="line">    │   ├── comment.js</div><div class="line">    │   ├── modal.js</div><div class="line">    │   ├── tab.js</div><div class="line">    │   ├── timer.js</div><div class="line">    │   ├── video.js</div><div class="line">    │   └── wysiwyg.js</div><div class="line">    │</div><div class="line">    └── application.js  // ~ 1KB of code; imports from ./components/</div></pre></td></tr></table></figure>
<p>结果是干净且可复用的代码。每个独立的组件取决于导入自身的依赖，并按照它想要的方式导出到其他模块。配合 Babel + ES6 使用，还可以利用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">JavaScript Classes</a> 做出更好的模块化，并且<strong>不要去想它</strong>，作用域只是在起作用。</p>
<p>想知道更多关于模块的内容，可以看这篇 Preethi Kasreddy 写的很棒的<a href="https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc" target="_blank" rel="external">文章</a>。</p>
<h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><ul>
<li><a href="https://gist.github.com/sokra/27b24881210b56bbaff7" target="_blank" rel="external">What’s New in Webpack 2</a></li>
<li><a href="https://blog.madewithenvy.com/webpack-2-postcss-cssnext-fdcd2fd7d0bd#.asbpg46l1" target="_blank" rel="external">Webpack + PostCSS + cssnext</a></li>
<li><a href="https://webpack.js.org/configuration/" target="_blank" rel="external">Webpack Config docs</a></li>
<li><a href="https://github.com/webpack/webpack/tree/master/examples" target="_blank" rel="external">Webpack Examples</a></li>
<li><a href="https://github.com/kriasoft/react-starter-kit" target="_blank" rel="external">React + Webpack Starter Kit</a></li>
<li><a href="https://github.com/petehunt/webpack-howto" target="_blank" rel="external">Webpack How-to</a></li>
</ul>
]]></content:encoded>
      
      <comments>http://llp0574.github.io/2016/11/29/getting-started-with-webpack2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git使用规范</title>
      <link>http://llp0574.github.io/2016/11/25/git-use/</link>
      <guid>http://llp0574.github.io/2016/11/25/git-use/</guid>
      <pubDate>Thu, 24 Nov 2016 16:35:10 GMT</pubDate>
      <description>
      
        &lt;p&gt;自定义的一套Git使用规范，感谢超哥，沿用至今。&lt;/p&gt;
&lt;h2 id=&quot;开发方式&quot;&gt;&lt;a href=&quot;#开发方式&quot; class=&quot;headerlink&quot; title=&quot;开发方式&quot;&gt;&lt;/a&gt;开发方式&lt;/h2&gt;&lt;p&gt;使用fork + pull request的开发流程。&lt;/p
      
      </description>
      
      <content:encoded><![CDATA[<p>自定义的一套Git使用规范，感谢超哥，沿用至今。</p>
<h2 id="开发方式"><a href="#开发方式" class="headerlink" title="开发方式"></a>开发方式</h2><p>使用fork + pull request的开发流程。</p>
<h2 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h2><p>首先将自己的公钥加入到github中</p>
<p>fork 主仓库代码后clone 下来</p>
<p>添加公共仓库到remote里, 名字命名为upstream</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># clone fork 仓库代码</div><div class="line">git clone your_fork_ssh_src</div><div class="line"></div><div class="line"># 添加远程仓库到remote 里</div><div class="line">git remote add upstream public_ssh_src</div><div class="line"></div><div class="line"># 查看remote</div><div class="line">git remote -v</div><div class="line"></div><div class="line">origin your_fork_ssh_src (fetch)</div><div class="line">origin your_fork_ssh_src (push)</div><div class="line"></div><div class="line">upstream public_ssh_src (fetch)</div><div class="line">upstream public_ssh_src (push)</div></pre></td></tr></table></figure>
<h2 id="分支使用"><a href="#分支使用" class="headerlink" title="分支使用"></a>分支使用</h2><p>git 鼓励多用分支，所以我们每天开发的新功能建议使用分支来区分，不要所有功能都放在一个分支上开发，分支命名规则如下：</p>
<ol>
<li>新功能命名: feature-xxx</li>
<li>bugfix命名: bugfix-xxx</li>
</ol>
<p>这样能解决一个问题，比如你开发新功能到一半，然后突然让你去修复一个紧急bug，如果你开发新功能的时候使用了feature分支，你只需要把的修改提交或者放到stash里就行，然后从master上切分支修复bug就行了，如果你没有切分支，那就很尴尬了。</p>
<p>master分支只用做更新远程master，每次开始工作前的第一条命令应该是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># 切换到master分支，并且把最新的代码同步下来</div><div class="line">git checkout master</div><div class="line">git pull --rebase upstream master</div></pre></td></tr></table></figure>
<p>计划今天要做的事和需要发布的内容，建好相应的分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 新建feature分支</div><div class="line">git checkout -b feature-xxx</div><div class="line"></div><div class="line"># 新建bugfix 分支</div><div class="line">git checkout -b hotfix-xxx</div></pre></td></tr></table></figure>
<p>coding…</p>
<h2 id="如何将代码合并到公共代码库"><a href="#如何将代码合并到公共代码库" class="headerlink" title="如何将代码合并到公共代码库"></a>如何将代码合并到公共代码库</h2><p>功能开发完成后，你只需要push到github,然后在github上提pull request到公共仓库的master就行。</p>
<h3 id="需要的配置"><a href="#需要的配置" class="headerlink" title="需要的配置:"></a>需要的配置:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git config -e</div><div class="line"></div><div class="line"># 然后添加如下代码到文件末尾</div><div class="line"># push 的时候之后将当前的分支push到远程，不会push所有分支</div><div class="line">[push]</div><div class="line">    default = current</div></pre></td></tr></table></figure>
<h3 id="push-代码"><a href="#push-代码" class="headerlink" title="push 代码:"></a>push 代码:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git push</div><div class="line"></div><div class="line"># 注意你本地可能会无法push，这时候你需要明白你本地代码是否</div><div class="line"># 是最新的，确定的话只需要使用 git push -f将代码提交到远端</div></pre></td></tr></table></figure>
<h3 id="合并提交历史和修改commit-msg"><a href="#合并提交历史和修改commit-msg" class="headerlink" title="合并提交历史和修改commit msg:"></a>合并提交历史和修改commit msg:</h3><p>功能开发完成后，你的提交历史也许会很乱，这个时候你需要使用rebase命令整理提交历史和commit msg：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rebase -i commit_id</div></pre></td></tr></table></figure>
<p>注意: 使用rebase 命令会改写历史，所以rebase操作一定是在本地操作，如果你的代码已经push到远程并且和别人协作了就一定不能进行rebase操作了。（目前我们不会出现这个问题）</p>
<h3 id="多人协作问题（为后期做准备）"><a href="#多人协作问题（为后期做准备）" class="headerlink" title="多人协作问题（为后期做准备）"></a>多人协作问题（为后期做准备）</h3><p>多人协作需要将其中一个人的feature分支作为主要分支来进行开发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># 添加协作人的remote</div><div class="line">git remote add company company_ssh_src</div><div class="line"></div><div class="line"># fetch分支下来</div><div class="line">git fetch company feature-xxx:feature-xxx</div><div class="line"></div><div class="line"># commit 以后先pull rebase</div><div class="line">git pull --rebase company feature-xxx</div><div class="line"></div><div class="line"># push</div><div class="line">git push company feature-xxx:feature-xxx</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>需要熟悉的命令有remote, pull, push, rebase, fetch, checkout, stash</p>
]]></content:encoded>
      
      <comments>http://llp0574.github.io/2016/11/25/git-use/#disqus_thread</comments>
    </item>
    
    <item>
      <title>一个健壮且可扩展的 CSS 架构所需的8个简单规则</title>
      <link>http://llp0574.github.io/2016/11/17/css-architecture/</link>
      <guid>http://llp0574.github.io/2016/11/17/css-architecture/</guid>
      <pubDate>Thu, 17 Nov 2016 15:31:08 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://github.com/jareware/css-architecture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;8 simple rules for a robust
      
      </description>
      
      <content:encoded><![CDATA[<blockquote>
<ul>
<li>原文地址：<a href="https://github.com/jareware/css-architecture" target="_blank" rel="external">8 simple rules for a robust, scalable CSS architecture</a></li>
<li>原文作者：<a href="https://github.com/jareware" target="_blank" rel="external">Jarno Rantanen</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="external">掘金翻译计划</a></li>
<li>译者：<a href="https://github.com/llp0574" target="_blank" rel="external">linpu.li</a></li>
<li>校对者：<a href="https://github.com/galenyuan" target="_blank" rel="external">galenyuan</a>，<a href="https://github.com/StarCrew" target="_blank" rel="external">StarCrew</a></li>
</ul>
</blockquote>
<p>这是一份清单，里面列出了在我多年的专业 Web 开发期间，在复杂的大型 Web 项目中学习到的有关管理 CSS 的事项。我多次被人问起这些东西，所以写一份文档记录下来听起来是个不错的主意。</p>
<p>我已经尽力尝试用简短的语言去解释它们了，然而这篇文章本质上还是长文慎入：</p>
<ol>
<li><a href="#1-always-prefer-classes"><strong>总是类名优先</strong></a></li>
<li><a href="#2-co-locate-component-code"><strong>组件代码放在一起</strong></a></li>
<li><a href="#3-use-consistent-class-namespacing"><strong>使用一致的类命名空间</strong></a></li>
<li><a href="#4-maintain-a-strict-mapping-between-namespaces-and-filenames"><strong>维护命名空间和文件名之间的严格映射</strong></a></li>
<li><a href="#5-prevent-leaking-styles-outside-the-component"><strong>避免组件外的样式泄露</strong></a></li>
<li><a href="#6-prevent-leaking-styles-inside-the-component"><strong>避免组件内的样式泄露</strong></a></li>
<li><a href="#7-respect-component-boundaries"><strong>遵守组件边界</strong></a></li>
<li><a href="#8-integrate-external-styles-loosely"><strong>松散地整合外部样式</strong></a></li>
</ol>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><a href="#introduction"></a>介绍</h2><p>如果你正在开发前端应用，那么最后你肯定需要关心样式方面的问题。尽管开发前端应用的技术水平持续增长，CSS 仍然是给 Web 应用赋予样式的唯一方式（而且最近，在某些情况下，<a href="https://facebook.github.io/react-native/" target="_blank" rel="external">原生应用也一样</a>）。目前在市面上有两大类样式解决方案，即：</p>
<ul>
<li>CSS 预编译器，已经存在很长时间了（如 <a href="http://sass-lang.com/" target="_blank" rel="external">SASS</a>、<a href="http://lesscss.org/" target="_blank" rel="external">LESS</a> 及其他）</li>
<li>CSS-in-JS 库，一个相对较新的样式解决方案（如 <a href="https://github.com/blakeembrey/free-style" target="_blank" rel="external">free-style</a> 和很多<a href="https://github.com/MicheleBertoli/css-in-js" target="_blank" rel="external">其他的</a>）</li>
</ul>
<p>两种方法间的抉择不在本文过多赘述，并且像往常一样，它们都有各自的支持者和反对者。说完这些，在下面的内容里，我将会专注于第一种方法，所以如果你选择了后者，那么这篇文章可能就没什么吸引力了。</p>
<h2 id="主要目标"><a href="#主要目标" class="headerlink" title="主要目标"></a><a href="#high-level-goals"></a>主要目标</h2><p>但更具体地说，怎样才能被称为健壮且可扩展呢？</p>
<ul>
<li><strong>面向组件</strong> - 处理 UI 复杂性的最佳实践就是将 UI 分割成一个个的小组件。如果你正在使用一个合理的框架，JavaScript 方面就将原生支持（组件化）。举个例子，<a href="https://facebook.github.io/react/" target="_blank" rel="external">React</a> 就鼓励高度组件化和分割。我们希望有一个 CSS 架构去匹配。</li>
<li><strong>沙箱化（Sandboxed）</strong> - 如果一个组件的样式会对其他组件产生不必要以及意想不到的影响，那么将 UI 分割成组件并不会对我们的认知负荷起到帮助作用。就这方面而言，CSS的基本功能，如<a href="https://developer.mozilla.org/en/docs/Web/Guide/CSS/Getting_started/Cascading_and_inheritance" target="_blank" rel="external">层叠（cascade）</a>以及一个针对标识符的独立全局命名空间，都会给你造成负担。如果你熟悉 Web 组件规范的话，那么就可以认为它（此架构）有着 <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/" target="_blank" rel="external">Shadow DOM 的样式隔离好处</a> ，而无需关心浏览器支持（或者规范是否经过严格的推敲）。</li>
<li><strong>方便</strong> - 我们想要所有好的东西，并且还不想因它们而产生更多的工作。也就是说，我们不想因为采用这个架构而让我们的开发者体验变得更糟。可能的话，我们想（开发者体验）变得更好。</li>
<li><strong>安全性错误</strong> - 结合之前的一点，我们想要所有东西都可以<strong>默认局部化</strong>，并且全局化只是一个特例。工程师都是很懒的，所以为了得到最容易的方法往往都需要使用合适的解决方案。</li>
</ul>
<h2 id="具体的规则"><a href="#具体的规则" class="headerlink" title="具体的规则"></a><a href="#concrete-rules"></a>具体的规则</h2><h3 id="1-总是类名优先"><a href="#1-总是类名优先" class="headerlink" title="1. 总是类名优先"></a><a href="#1-always-prefer-classes"></a>1. 总是类名优先</h3><p>这是显而易见的。</p>
<p>不要去使用 ID 选择器 (如 <code>#header</code>)，因为每当你认为某样东西只会有一个实例的时候，<a href="https://twitter.com/stedwick/status/525777867146539009" target="_blank" rel="external">在无限的时间范围内</a>，你都将被证明是错的。一个典型的例子就是，当想要在我们构建的大型应用中修复任何数据绑定漏洞的时候（这种情况尤为明显）。我们从为 UI 代码创建两个实例开始，它们并行在同一个 DOM，并都绑定到一个数据模型的共享实例上。这么做是为了保证所有数据模型的变化都可以正确体现到这两个 UI 上。所以任何你可能假设总是唯一的组件，如一个头部模板，就不再唯一了。顺便一提，这对找出其他唯一性假设相关的细微漏洞来说，也是一个很好的基准。我跑题了，但这个故事告诉我们的就是：没有一种情况是使用 ID 选择器会比使用类选择器<strong>更好</strong>，所以只要不使用就行了。</p>
<p>同样也不应该直接使用元素选择器（如 <code>p</code>）。通常对一个<strong>属于组件</strong>的元素使用元素选择器是可以的（看下面），但是对于元素本身来说，最终你将会为了一个不想使用它们的组件，而不得不<a href="http://csswizardry.com/2012/11/code-smells-in-css/" target="_blank" rel="external">将那些样式给撤销掉</a>。回想一下我们的主要目标，这同样也违背了它们（面向组件，避免折磨人的层叠（cascade），以及默认局部化）。如果你这么选择的话，那么在<code>body</code>上设置一些像字体，行高以及颜色的属性（也叫<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/inheritance" target="_blank" rel="external">可继承属性</a>），对这个规则来说也可以是一个特例，但是如果你真正想做到组件隔离的话，那么放弃这些也完全是可行的（看下面关于<a href="#8-integrate-external-styles-loosely">使用外部样式的部分</a>）。</p>
<p>所以在极少特例的情况下，你的样式应该总是类名优先。</p>
<h3 id="2-组件代码放在一起"><a href="#2-组件代码放在一起" class="headerlink" title="2. 组件代码放在一起"></a><a href="#2-co-locate-component-code"></a>2. 组件代码放在一起</h3><p>当使用一个组件的时候，如果所有和组件相关的资源（其 JavaScript 代码，样式，测试用例，文档等等）都可以非常紧密地放在一起，那就更好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ui/</div><div class="line">├── layout/</div><div class="line">|   ├── Header.js              // component code</div><div class="line">|   ├── Header.scss            // component styles</div><div class="line">|   ├── Header.spec.js         // component-specific unit tests</div><div class="line">|   └── Header.fixtures.json   // any mock data the component tests might need</div><div class="line">├── utils/</div><div class="line">|   ├── Button.md              // usage documentation for the component</div><div class="line">|   ├── Button.js              // ...and so on, you get the idea</div><div class="line">|   └── Button.scss</div></pre></td></tr></table></figure>
<p>当你写代码的时候，只需要简单地打开项目的浏览工具，组件的所有其他内容都唾手可得了。样式代码和生成DOM的JavaScript之间有着天然的耦合性，而且我敢打赌你在修改完其中一个之后不久肯定会去修改另外一个。举例来说，这同样适用于组件及其测试代码。可以认为这就是 UI 组件的<a href="https://en.wikipedia.org/wiki/Locality_of_reference" target="_blank" rel="external">访问局部性原理</a>。我以前也会细致地去维护各种独立的镜像文件，它们各自存在 <code>styles/</code>、 <code>tests/</code> 和 <code>docs/</code> 等目录下面，直到我意识到，实际上我一直这么做的唯一原因是因为我就是一直这样做的。</p>
<h3 id="3-使用一致的类命名空间"><a href="#3-使用一致的类命名空间" class="headerlink" title="3. 使用一致的类命名空间"></a><a href="#3-use-consistent-class-namespacing"></a>3. 使用一致的类命名空间</h3><p>CSS 对类名及其他标识符（如 ID、动画名称等）都有一个独立扁平的命名空间。就像过去在 PHP 里，其社区想通过简单地使用更长且具有结构性的名称来处理这个问题，因此就效仿了命名空间（<a href="http://getbem.com/" target="_blank" rel="external">BEM</a> 就是个例子）。我们也想要选择一个命名空间规范，并坚持下去。</p>
<p>比如，使用 <code>myapp-Header-link</code> 来当做一个类名，组成它的三个部分都有着特定的功能：</p>
<ul>
<li><code>myapp</code> 首先用来将我们的应用和其他可能运行在同一个 DOM 上的应用隔离开来</li>
<li><code>Header</code> 用来将组件和应用里其他的组件隔离开来</li>
<li><code>link</code> 用来为局部样式效果保存一个局部名称（在组件的命名空间内）</li>
</ul>
<p>作为一个特殊的情况，<code>Header</code> 组件的根元素可以简单地用 <code>myapp-Header</code> 类来标记。对于一个非常简单的组件来说，这可能就是所需要做的全部了。</p>
<p>不管我们选择怎样的命名空间规范，我们都想要通过它保持一致性。那三个类名组成部分除了有着特定<strong>功能</strong>，也同样有着特定的<strong>含义</strong>。只需要看一下类名，就可以知道它属于哪里了。这样的命名空间将成为我们浏览项目样式的地图。</p>
<p>目前为止我都假设命名空间的方案为 <code>app-Component-class</code>，这是我个人在工作当中发现确实好用的方案，当然你也可以琢磨出自己的一套来。</p>
<h3 id="4-维护命名空间和文件名之间的严格映射"><a href="#4-维护命名空间和文件名之间的严格映射" class="headerlink" title="4. 维护命名空间和文件名之间的严格映射"></a><a href="#4-maintain-a-strict-mapping-between-namespaces-and-filenames"></a>4. 维护命名空间和文件名之间的严格映射</h3><p>这只是对之前两条规则的逻辑组合（组件代码放在一起以及类命名空间）：所有影响一个特定组件的样式都应该放到一个文件里，并以组件命名，没有例外。</p>
<p>如果你正在使用浏览器，然后发现一个组件表现异常，那么你就可以点击右键检查它，接着你就会看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;myapp-Header&quot;&gt;...&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>注意到组件名称，然后切换至你的编辑器，按下“快速打开文件”的快捷键，然后开始输入“head”，就可以看到：</p>
<p><a href="/jareware/css-architecture/blob/master/quick-open-file.png"><img src="https://github.com/jareware/css-architecture/raw/master/quick-open-file.png" alt="Quick open file"></a></p>
<p>这种来自 UI 组件关联源代码文件的严格映射非常有用，特别是如果你新进入一个团队并且还没有完全熟悉代码结构，通过这个方法你不需要熟悉就可以快速找到你应该写代码的地方了。</p>
<p>有一个对这种方法的自然推论（但或许不是那么快变得明显）：一个单独的样式文件应该只包含属于一个独立命名空间的样式。为什么？假设我们有一个登录表单，只在 <code>Header</code> 组件内使用。在 JavaScript 代码层面，它被定义成一个名为 <code>Header.js</code> 的辅助组件，并且没有在任何地方被引入。你可能想声明一个类名为 <code>myapp-LoginForm</code>，并在 <code>Header.js</code> 和 <code>Header.scss</code> 里使用。那么假设团队里有一个新人被安排去修复登录表单上一个很小的布局问题，并想通过检查元素发现在哪里开始修改。然而并没有 <code>LoginForm.js</code> 或者 <code>LoginForm.scss</code> 可以被发现，这时他就不得不凭借 <code>grep</code> （Linux 命令）或者靠猜去寻找相关联的源代码文件。这也就是说，如果这个登录表单产生了一个独立的命名空间，那么就应该将其分割成一个独立的组件。一致性在大型项目里是非常有价值的。</p>
<h3 id="5-避免组件外的样式泄露"><a href="#5-避免组件外的样式泄露" class="headerlink" title="5. 避免组件外的样式泄露"></a><a href="#5-prevent-leaking-styles-outside-the-component"></a>5. 避免组件外的样式泄露</h3><p>我们已经建立了自己的命名空间规范，并且现在想使用它们去沙箱化我们的 UI 组件。如果每个组件都只使用加上它们唯一的命名空间前缀的类名，那我们就可以确定它们的样式不会泄露到其他组件中去。这是非常高效的（看后面的注意事项），但是不得不反复输入命名空间也会变得越来越冗长乏味。</p>
<p>一个健壮，且仍然非常简单的解决方案就是将整个样式文件包装成一个前缀。注意我们是怎样做到只需要重复一次应用和组件名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.myapp-Header &#123;</div><div class="line">  background: black;</div><div class="line">  color: white;</div><div class="line"></div><div class="line">  &amp;-link &#123;</div><div class="line">    color: blue;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  &amp;-signup &#123;</div><div class="line">    border: 1px solid gray;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子是在 SASS 中实现的，但其中的 <code>&amp;</code> 符号（或许让人有点惊讶）在所有相关的 CSS 预处理器中都做着同样的工作（<a href="http://sass-lang.com/" target="_blank" rel="external">SASS</a>、<a href="https://github.com/postcss/postcss-nested" target="_blank" rel="external">PostCSS</a>、<a href="http://lesscss.org/" target="_blank" rel="external">LESS</a> 以及 <a href="http://stylus-lang.com/" target="_blank" rel="external">Stylus</a>）。出于完整性，接下来给出上面 SASS 代码编译后的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.myapp-Header &#123;</div><div class="line">  background: black;</div><div class="line">  color: white;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.myapp-Header-link &#123;</div><div class="line">  color: blue;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.myapp-Header-signup &#123;</div><div class="line">  border: 1px solid gray;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有常见的模式也可以使用它很好地表示出来，比如不同的组件状态有着不同的样式（想想 <a href="http://getbem.com/naming/" target="_blank" rel="external">BEM 条件下的修饰符</a>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.myapp-Header &#123;</div><div class="line"></div><div class="line">  &amp;-signup &#123;</div><div class="line">    display: block;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  &amp;-isScrolledDown &amp;-signup &#123;</div><div class="line">    display: none;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的编译结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.myapp-Header-signup &#123;</div><div class="line">  display: block;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.myapp-Header-isScrolledDown .myapp-Header-signup &#123;</div><div class="line">  display: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只要你的预编译器支持冒泡（SASS、LESS、PostCSS 和 Stylus 都可以做到），甚至媒体查询也可以很方便表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.myapp-Header &#123;</div><div class="line"></div><div class="line">  &amp;-signup &#123;</div><div class="line">    display: block;</div><div class="line"></div><div class="line">    @media (max-width: 500px) &#123;</div><div class="line">      display: none;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码就会变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.myapp-Header-signup &#123;</div><div class="line">  display: block;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@media (max-width: 500px) &#123;</div><div class="line">  .myapp-Header-signup &#123;</div><div class="line">    display: none;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的模式让使用长且唯一的类名变得非常方便，因为你再也无需反复输入它们了。方便性是强制的，因为如果不方便，那么我们就会偷工减料了。</p>
<h3 id="JS-端的快速一览"><a href="#JS-端的快速一览" class="headerlink" title="JS 端的快速一览"></a><a href="#quick-aside-on-the-js-side-of-things"></a>JS 端的快速一览</h3><p>这篇文档是关于样式规范的，但样式是不能凭空独立存在的：我们在 JS 端也需要产生同样的命名空间化类名，并且方便性也是强制的。</p>
<p>厚着脸皮做个广告，我恰好为此曾经建立了一个非常简单，无任何依赖的 JS 库，叫做 <a href="https://github.com/jareware/css-ns" target="_blank" rel="external"><code>css-ns</code></a>。当在框架层面编译的时候（<a href="https://github.com/jareware/css-ns#use-with-react" target="_blank" rel="external">比如使用 React</a>），它允许在一个特定文件内<strong>强制</strong>建立一个特定的命名空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// Create a namespace-bound local copy of React:</div><div class="line">var &#123; React &#125; = require(&apos;./config/css-ns&apos;)(&apos;Header&apos;);</div><div class="line"></div><div class="line">// Create some elements:</div><div class="line">&lt;div className=&quot;signup&quot;&gt;</div><div class="line">  &lt;div className=&quot;intro&quot;&gt;...&lt;/div&gt;</div><div class="line">  &lt;div className=&quot;link&quot;&gt;...&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>将渲染出的 DOM 如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;myapp-Header-signup&quot;&gt;</div><div class="line">  &lt;div class=&quot;myapp-Header-intro&quot;&gt;...&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;myapp-Header-link&quot;&gt;...&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>这真的非常方便，并且上面所有的代码让 JS 端也变成了<strong>默认局部化</strong>。</p>
<p>但是我再次跑题了，回到 CSS 端。</p>
<h3 id="6-避免组件内的样式泄露"><a href="#6-避免组件内的样式泄露" class="headerlink" title="6. 避免组件内的样式泄露"></a><a href="#6-prevent-leaking-styles-inside-the-component"></a>6. 避免组件内的样式泄露</h3><p>还记得我说过给每个类名加上组件命名空间的前缀时，这是对沙箱化样式来说很高效的一种方式吗？还记得我说过这里有个“注意事项”吗？</p>
<p>考虑下面的样式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.myapp-Header &#123;</div><div class="line">  a &#123;</div><div class="line">    color: blue;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以及下面的组件层：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+-------------------------+</div><div class="line">| Header                  |</div><div class="line">|                         |</div><div class="line">| [home] [blog] [kittens] | &lt;-- 这些都是 &lt;a&gt; 元素</div><div class="line">+-------------------------+</div></pre></td></tr></table></figure></p>
<p>这很酷，不是吗？<code>Header</code> 里只有 <code>&lt;a&gt;</code> 元素会变成<a href="https://www.youtube.com/watch?v=axHe_BVY_9c" target="_blank" rel="external">蓝色</a>，因为我们生成的规则如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.myapp-Header a &#123; color: blue; &#125;</div></pre></td></tr></table></figure>
<p>但是考虑布局在之后做一下变化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+-----------------------------------------+</div><div class="line">| Header                    +-----------+ |</div><div class="line">|                           | LoginForm | |</div><div class="line">|                           |           | |</div><div class="line">| [home] [blog] [kittens]   | [info]    | | &lt;-- 这些是 &lt;a&gt; 元素</div><div class="line">|                           +-----------+ |</div><div class="line">+-----------------------------------------+</div></pre></td></tr></table></figure></p>
<p>选择器 <code>.myapp-Header a</code> <strong>同样匹配</strong>了 <code>LoginForm</code> 里的 <code>&lt;a&gt;</code> 元素，所以我们搞砸了这里的样式隔离。事实证明，将所有样式包装到一个命名空间里对于隔离组件及其邻居组件来说，是一个高效的方式，<strong>但却不能总是和其子组件隔离</strong>。</p>
<p>这个问题可以通过两种方法修复：</p>
<ol>
<li>绝不在样式表中使用元素名称选择器。如果 <code>Header</code> 里的 <code>&lt;a&gt;</code> 元素都使用 <code>&lt;a class=&quot;myapp-Header-link&quot;&gt;</code> 替代，那么我们就不需要处理这个问题了。再往下看，有时候你会设置一些语义化标签，像 <code>&lt;article&gt;</code>、<code>&lt;aside&gt;</code> 以及 <code>&lt;th&gt;</code>，都放在了正确的位置上，并且你又不想用额外的类名来弄乱它们，这种情况下：</li>
<li>在你的命名空间之外只使用 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Child_selectors" target="_blank" rel="external"><code>&gt;</code> 操作符</a> 来选择元素。</li>
</ol>
<p>根据第二个方法来做调整，我们的样式代码就可以改写如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.myapp-Header &#123;</div><div class="line">  &gt; a &#123;</div><div class="line">    color: blue;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就可以确保隔离同样作用于更深层次的组件树，因为生成的选择器变成了 <code>.myapp-Header &gt; a</code>。</p>
<p>如果这听起来有争议，那么让我通过下面这个同样运行良好的例子更进一步地使你信服：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.myapp-Header &#123;</div><div class="line">  &gt; nav &gt; p &gt; a &#123;</div><div class="line">    color: blue;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经过<a href="http://lmgtfy.com/?q=css+nesting+harmful" target="_blank" rel="external">多年的可靠建议</a>，我们一直认为要尽量避免选择器嵌套（包括这个使用了 <code>&gt;</code> 的强关联形式）。但是为什么呢？这个引用的原因归结为以下三个：</p>
<ol>
<li>层叠样式最终会毁掉你的一天。要是嵌套越多的选择器，那么就有越高的机会造成一个元素匹配上<strong>多于一个组件</strong>的情况。如果你读到这里，你就会知道我们已经消除了这种可能性了（使用严格的命名空间前缀，并在需要的时候使用强关联子元素选择器）。</li>
<li>太多的特性会减少可复用性。写给 <code>nav p a</code> 的样式将不能在特定情况下之外的任意地方被复用。但其实我们<strong>从来没想要它可复用</strong>，事实上，我们特意禁止这个可复用的方法，因为这种可复用性并不能在我们想实现组件隔离的目标上产生好的作用。</li>
<li>太多的特性会让重构变得更加困难。这可以在现实中找到依据，假设你只有一个 <code>.myapp-Header-link a</code>，你可以很自由地在组件的 HTML 中移动 <code>&lt;a&gt;</code> 元素，同样的样式总是会一直生效。然而如果使用 <code>&gt; nav &gt; p &gt; a</code>，就需要更新选择器去匹配组件的 HTML 内这个链接的新位置。但考虑到我们想要 UI 是由一些小且隔离性好的组件组成，这个问题也不是相当重要。当然，如果你不得不在重构的时候考虑整个应用的 HTML 和 CSS，那么这个问题可能就有点严重了。但是现在你是在一个只有十行样式代码的小沙箱内进行操作，并且还知道沙箱外没有其他东西需要考虑，那么这种类型的变化就不是问题了。</li>
</ol>
<p>通过这个例子，你应该很好的理解了规则，所以你知道什么时候应该打破它们。在我们的架构里，选择器嵌套不仅仅只是可以用，有时候它还是一件非常正确的事情。为之疯狂吧。</p>
<h3 id="出于好奇的题外话：预防泄露样式进入组件"><a href="#出于好奇的题外话：预防泄露样式进入组件" class="headerlink" title="出于好奇的题外话：预防泄露样式进入组件"></a><a href="#an-aside-for-the-curious-prevent-leaking-styles-into-the-component"></a>出于好奇的题外话：预防泄露样式<strong>进入</strong>组件</h3><p>所以我们是否已经实现了样式的完美沙箱化，以至于每个组件的存在都可以和页面的其他内容隔离开来呢？做一个快速回顾：</p>
<ul>
<li><p>我们已经通过用组件的命名空间给每个类名加前缀来避免<strong>组件向外泄露样式</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+-------+</div><div class="line">|       |</div><div class="line">|    -----X---&gt;</div><div class="line">|       |</div><div class="line">+-------+</div></pre></td></tr></table></figure>
</li>
<li><p>引申开来，这也意味着我们已经避免了<strong>组件间的泄露</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+-------+     +-------+</div><div class="line">|       |     |       |</div><div class="line">|    ------X------&gt;   |</div><div class="line">|       |     |       |</div><div class="line">+-------+     +-------+</div></pre></td></tr></table></figure>
</li>
<li><p>而且我们还通过考虑子选择器来避免<strong>泄露进入子组件</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+---------------------+</div><div class="line">|           +-------+ |</div><div class="line">|           |       | |</div><div class="line">|    ----X------&gt;   | |</div><div class="line">|           |       | |</div><div class="line">|           +-------+ |</div><div class="line">+---------------------+</div></pre></td></tr></table></figure>
</li>
<li><p>但更为关键的是，<strong>外部样式仍然可以泄露进入组件当中</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">      +-------+</div><div class="line">      |       |</div><div class="line">----------&gt;   |</div><div class="line">      |       |</div><div class="line">      +-------+</div></pre></td></tr></table></figure>
</li>
</ul>
<p>举个例子，假设我们给组件写了下面的样式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.myapp-Header &#123;</div><div class="line">  &gt; a &#123;</div><div class="line">    color: blue;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是接着我们引入一个表现不好的第三方库，有着下面的 CSS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a &#123;</div><div class="line">  font-family: &quot;Comic Sans&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>没有一个简单的方法可以保护我们的组件不受外部样式的污染</strong>，并且这是我们经常需要调整的地方：</p>
<p><a href="/jareware/css-architecture/blob/master/give-up.gif"><img src="https://github.com/jareware/css-architecture/raw/master/give-up.gif" alt="Give up"></a></p>
<p>幸好，对于你自己使用的依赖来说常常会有一个控制方式，并且也可以简单地找一个表现更好的选择。</p>
<p>而且，我说的是没有一个<strong>简单的</strong>的方法可以保护组件，并不意味着没有方法。<a href="https://www.youtube.com/watch?v=20wUS_bbOHY" target="_blank" rel="external">老兄，当然是有方法的</a>，它们只是有不同的取舍：</p>
<ul>
<li>只需强制覆盖它：如果你为每个组件的每个元素去引入一个 <a href="http://cssreset.com/what-is-a-css-reset/" target="_blank" rel="external">CSS 重置样式</a>，并且使用一个优先级总是高于其他第三方库的选择器，那么就非常棒了。但是除非是一个小应用（假设一个第三方“共享”按钮可以嵌入到网站上那种），否则这种方法将会迅速失控。这不算是一个好主意，只是在这里列出来等待完善。</li>
<li><a href="https://developer.mozilla.org/en/docs/Web/CSS/all" target="_blank" rel="external"><code>all: initial</code></a> 是一个很少人知道的新 CSS 属性，它专门为了这个问题而设计。它可以<a href="https://jsfiddle.net/0d9htatc/" target="_blank" rel="external">阻止继承属性流入</a>，并且<a href="https://jsfiddle.net/e7rw4L8L/" target="_blank" rel="external">只要它赢得了特性之争</a>（并且只要你为每个想保护的属性重复使用它），还可以作为一个本地重置生效。它的实现<a href="https://speakerdeck.com/csswizardry/refactoring-css-without-losing-your-mind?slide=39" target="_blank" rel="external">有些错综复杂</a>，而且还不是所有浏览器都<a href="http://caniuse.com/#feat=css-all" target="_blank" rel="external">支持</a>，但是 <code>all: initial</code> 最后或许可以成为样式隔离的有效方法。</li>
<li>Shadow DOM 已经被提到过，而它正是为你解决问题的一个工具，因为它允许为 JS 和 CSS 声明组件边界。尽管最近有<a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewInSafari/Articles/Safari_10_0.html" target="_blank" rel="external">一丝希望的微光</a>，Web 组件规范还是没有在今年取得很大的进步，并且除非你使用的是一些已知可支持的浏览器，否则还是不能将 Shadow DOM 列入考虑范围。</li>
<li>最后，还有 <code>&lt;iframe&gt;</code>。它提供了 Web 运行环境所能提供的最强的隔离形式（既为 JS 也为 CSS），但同样为运行成本（潜在因素）和维护（保留的内存）带来了巨大的消耗。不过，通常代价是值得的，并且最著名的网络嵌入（Facebook、Twitter、Disqus等等）事实上也是用 iframe 实现的。然而本文档的目的是隔离成千上百个小组件，就此而言，这个方法将数以百倍地消耗我们的性能。</li>
</ul>
<p>不管怎样，这个题外话跑得有点远了，回到我们的 CSS 规则。</p>
<h3 id="7-遵守组件边界"><a href="#7-遵守组件边界" class="headerlink" title="7. 遵守组件边界"></a><a href="#7-respect-component-boundaries"></a>7. 遵守组件边界</h3><p>就像我们赋予 <code>.myapp-Header &gt; a</code> 的样式，当嵌套组件的时候，我们可能还需要给子组件提供一些样式（Web 组件类比再次完美，因为接下来 <code>&gt; a</code> 和 <code>&gt; my-custom-a</code> 的效果并没有什么差异）。考虑下面的布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+---------------------------------+</div><div class="line">| Header           +------------+ |</div><div class="line">|                  | LoginForm  | |</div><div class="line">|                  |            | |</div><div class="line">|                  | +--------+ | |</div><div class="line">| +--------+       | | Button | | |</div><div class="line">| | Button |       | +--------+ | |</div><div class="line">| +--------+       +------------+ |</div><div class="line">+---------------------------------+</div></pre></td></tr></table></figure></p>
<p>我们马上可以看到用 <code>.myapp-Header .myapp-Button</code> 写样式不会是一个好主意，显然应该用 <code>.myapp-Header &gt; .myapp-Button</code> 来替代。但是我们到底要给子组件提供什么样式呢？</p>
<p>注意到 <code>LoginForm</code> 靠在了 <code>Header</code> 的右边界上。直观看来，一个可能的样式就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.myapp-LoginForm &#123;</div><div class="line">  float: right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们没有违反任何规则，但是我们让 <code>LoginForm</code> 变得有点难以复用了：如果我们接下来的主页想要这个 <code>LoginForm</code>，但是不想要右浮动，那就不走运了。</p>
<p>这个问题实际的解决方案就是（局部地）放宽之前的规则，只对当前文件所属的命名空间提供样式。具体来说，我们希望用下面的代码替换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.myapp-Header &#123;</div><div class="line">  &gt; .myapp-LoginForm &#123;</div><div class="line">    float: right;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样实际上已经很好了，只要我们不允许随意地破坏子组件的沙箱：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.myapp-Header &#123;</div><div class="line">  &gt; .myapp-LoginForm &#123;</div><div class="line">    color: blue;</div><div class="line">    padding: 20px;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// COUNTER-EXAMPLE; DON&apos;T DO THIS</div></pre></td></tr></table></figure>
<p>我们不允许这么做，因为这样做会失去局部变化没有全局影响的安全性。使用上面代码的话，当修改 <code>LoginForm</code> 组件表现的时候，<code>LoginForm.scss</code> 就不再是唯一需要检查的地方了。发生变化再次变得可怕。所以可用与不可用之间的界限到底在哪里？</p>
<p>我们希望遵守每个子组件<strong>内部</strong>的沙箱，因为我们不想依赖其实现细节。它对于我们来说是个黑盒。相反地，在子组件<strong>外部</strong>的是父组件的沙箱，它占据着主要位置。区分内部和外部正好引出了 CSS 中最基本的概念之一：<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model" target="_blank" rel="external">盒模型</a>。</p>
<p><a href="/jareware/css-architecture/blob/master/box-model.png"><img src="https://github.com/jareware/css-architecture/raw/master/box-model.png" alt="CSS Box Model"></a></p>
<p>我做的这个类比很糟糕，但我们继续看：就像<strong>在一个国家内</strong>意味着在其物理边界之内，我们建立了一个边界，父组件只可以在子组件边界之外对（直接）子组件样式产生影响。这意味着关系到位置和大小的属性（如 <code>position</code>、<code>margin</code>、<code>display</code>、<code>width</code>、<code>float</code>、<code>z-index</code> 等等）是可用的，而影响到内部边界的属性（如 <code>border</code> 本身、<code>padding</code>、<code>color</code>、<code>font</code>等）是不可用的。</p>
<p>按照推论，下面这样显然也是禁止的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.myapp-Header &#123;</div><div class="line">  &gt; .myapp-LoginForm &#123;</div><div class="line">    &gt; a &#123; // relying on implementation details of LoginForm ;__;</div><div class="line">      color: blue;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// COUNTER-EXAMPLE; DON&apos;T DO THIS</div></pre></td></tr></table></figure>
<p>有几个有趣或者说无聊的边界情况，比如：</p>
<ul>
<li><code>box-shadow</code> - 一个特定类型的 shadow 可以是一个组件外观不可缺少的部分，因此组件应该自己包含这些样式。话又说回来，这种视觉效果可以在边界外清楚地渲染出来，所以它又可以回到父组件的作用域。</li>
<li><code>color</code>, <code>font</code> 及其他<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/inheritance" target="_blank" rel="external">可继承属性</a> - <code>.myapp-Header &gt; .myapp-LoginForm { color: red }</code> 这种写法碰到了子组件内部的属性，但从另一方面来说，这又可以在功能上等同于 <code>.myapp-Header { color: red; }</code>，这种写法根据其他规则又是可行的。</li>
<li><code>display</code> - 如果子组件使用了 <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="external">Flexbox</a> 布局，那么它很可能依赖于其根元素上设置 <code>display: flex</code> 属性。不过，父组件也可能选择通过 <code>display: none</code> 来隐藏其子组件。</li>
</ul>
<p>在这些边界情况下要意识到一件重要的事情，你并不是在冒着打核战争的危险，而只是在引入少量的 CSS 层叠好回到自己的样式。就和其他不好的做法一样，适当地使用层叠是可以的。例如，再仔细看到最后的例子，<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity" target="_blank" rel="external">特性优先级比较</a>正如你所想要的效果一样：当组件可见时，<code>.myapp-LoginForm { display: flex }</code> 的优先级更高。而当拥有者决定用 <code>.myapp-Header-loginBoxHidden &gt; .myapp-LoginBox { display: none }</code> 隐藏组件时，这个样式的优先级更高。</p>
<h3 id="8-松散地整合外部样式"><a href="#8-松散地整合外部样式" class="headerlink" title="8. 松散地整合外部样式"></a><a href="#8-integrate-external-styles-loosely"></a>8. 松散地整合外部样式</h3><p>为了避免重复工作，有时可能需要在组件间共享样式。为了避免全部工作，有时又可能想使用其他人创建的样式。这两种情况的实现都不应该创建出不必要的耦合到代码库中。</p>
<p>拿一个具体的例子来说，考虑使用一些来自 <a href="http://getbootstrap.com/css/" target="_blank" rel="external">Bootstrap</a> 的样式，因为这对于使用恼人的框架来说是一个很好的例子。想想我们上面所讨论到的所有事情，关于为样式共享一个独立的全局命名空间，以及不好的冲突，Bootstrap 会：</p>
<ul>
<li>导出一大堆选择器（版本 3.3.7 来说, 具体有 2481 个）到命名空间里，不管你实际上是否使用它们。（有趣的一面：IE9 在默认忽略剩余选择器之前只会处理 4095 个选择器。我曾经听说有人花了<strong>很多天</strong>来调试它们，鬼知道他们经历了什么。）</li>
<li>使用写死的类名如 <code>.btn</code> 和 <code>.table</code>。不敢想象某些不小心复用了这些样式的开发者或者项目。（讽刺脸）</li>
</ul>
<p>不管了，我们希望使用 Bootstrap 作为 <code>Button</code> 组件的基础。</p>
<p>用某段代码替换下面的来整合到 HTML 端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;button class=&quot;myapp-Button btn&quot;&gt;</div></pre></td></tr></table></figure>
<p>考虑在样式中<a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#extend" target="_blank" rel="external">扩展</a>这个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;button class=&quot;myapp-Button&quot;&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.myapp-Button &#123;</div><div class="line">  @extend .btn; // from Bootstrap</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这么做有一个好处，那就是没有给任何人（包括你自己）产生一种想法：在 HTML 组件上去依赖可笑地命名为 <code>btn</code> 的类。<code>Button</code> 所使用的样式的来源是一个完全不需要显示在外面的实现细节。因此，如果你决定放弃 Bootstrap 转而支持另外的框架（或者只是你自己去写样式），那么这种改变无论如何都不会外部可见（呃，除非，这种可见变化是在于 <code>Button</code> 本身长什么样子）。</p>
<p>同样的原则适用于你自己的辅助类，并且你可以选择使用更合理的类名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.myapp-Button &#123;</div><div class="line">  @extend .myapp-utils-button; // defined elsewhere in your project</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者<a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#placeholder_selectors_" target="_blank" rel="external">干脆放弃放出类</a>（<a href="https://csspre.com/placeholder-selectors/" target="_blank" rel="external">大部分预编译器都可以支持</a>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.myapp-Button &#123;</div><div class="line">  @extend %myapp-utils-button; // defined elsewhere in your project</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，所有的 CSS 预编译器都支持 <a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixins" target="_blank" rel="external">mixins</a> 的概念，这可是一个强有力的工具：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.myapp-Button &#123;</div><div class="line">  @include myapp-generateCoolButton($padding: 15px, $withExplosions: true);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>应该注意的是当处理更友好的样式框架时（如 <a href="http://bourbon.io/" target="_blank" rel="external">Bourbon</a> 或者 <a href="http://foundation.zurb.com/" target="_blank" rel="external">Foundation</a>），它们实际上会这么做：定义一大堆 mixin 给你去在需要的时候使用，并且它们本身没有放出任何样式。如 <a href="http://neat.bourbon.io/" target="_blank" rel="external">Neat</a> 框架。</p>
<h2 id="在结束前"><a href="#在结束前" class="headerlink" title="在结束前"></a><a href="#in-closing"></a>在结束前</h2><blockquote>
<p>知晓所有规则，所以知道何时打破它们</p>
</blockquote>
<p>最后，如前所述，当你理解了你所制定的规则（或者是从网上其他人那儿采取的），你就可以写出对你有意义的特例。比如，如果你觉得直接使用一个辅助类是有附加价值的，那么就可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;button class=&quot;myapp-Button myapp-utils-button&quot;&gt;</div></pre></td></tr></table></figure>
<p>这种附加价值可能是，比如说，你的测试框架之后可以更智能地自动找出什么元素表现为按钮，以及可以被点击。</p>
<p>或者你可能会在违背程度很小的情况下决定去打破组件隔离，并且分割组件的额外工作可能会变得更好。但我想要提醒的是这就像是个下坡路，而且不要忘了一致性的重要性等等，只要你的团队保持一致，并且你可以完成它们，那么你就是在做对的事情。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a><a href="#the-end"></a>结语</h2><p>如果你喜欢这篇文章，你完全可以 <a href="https://twitter.com/home?status=8%20simple%20rules%20for%20a%20robust,%20scalable%20CSS%20architecture%3A%20https%3A//github.com/jareware/css-architecture" target="_blank" rel="external">tweet 关于它的内容！</a>或者不。</p>
<h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a><a href="#license"></a>证书</h2><p><a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="external">CC BY 4.0</a></p>
]]></content:encoded>
      
      <comments>http://llp0574.github.io/2016/11/17/css-architecture/#disqus_thread</comments>
    </item>
    
    <item>
      <title>VUE 和 VUEX 中的数据流</title>
      <link>http://llp0574.github.io/2016/10/14/data-flow-in-vue-and-vuex/</link>
      <guid>http://llp0574.github.io/2016/10/14/data-flow-in-vue-and-vuex/</guid>
      <pubDate>Fri, 14 Oct 2016 15:21:16 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://benjaminlistwon.com/blog/data-flow-in-vue-and-vuex/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DATA FLOW IN
      
      </description>
      
      <content:encoded><![CDATA[<blockquote>
<ul>
<li>原文地址：<a href="https://benjaminlistwon.com/blog/data-flow-in-vue-and-vuex/" target="_blank" rel="external">DATA FLOW IN VUE AND VUEX</a></li>
<li>原文作者：本文已获得原作者 <a href="https://benjaminlistwon.com/about/" target="_blank" rel="external">Benjamin Listwon</a> 的授权</li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="external">掘金翻译计划</a></li>
<li>译者：<a href="https://github.com/llp0574" target="_blank" rel="external">linpu.li</a></li>
<li>校对者：<a href="https://github.com/malcolmyu" target="_blank" rel="external">malcolmyu</a>，<a href="https://github.com/XatMassacrE" target="_blank" rel="external">XatMassacrE</a></li>
</ul>
</blockquote>
<p>看起来在 <a href="https://vuejs.org" target="_blank" rel="external">Vue</a> 里面困扰开发者的事情之一是如何在组件之间共享状态。对于刚刚接触响应式编程的开发者来说，像<a href="https://github.com/vuejs/vuex/" target="_blank" rel="external">Vuex</a> 这种库，有着繁多的新名词及其关注点分离的方式，往往令人望而生畏。特别是当你只希望分享一两个数据片段时，（这一套逻辑的复杂性）就显得有点过分了。</p>
<p>考虑到这一点的话，我想我应该把两个简短的演示放到一起展示出来。第一个通过使用一个简单的 JavaScript 对象，在每个新组件当中引用来实现共享状态。第二个做了和 Vuex 一样的事情，当它运行成功的时候，也是一个你绝对不应该做的事情的示例（我们将在最后看看为什么）。</p>
<p>你可以通过查看下面这些演示来开始：</p>
<ul>
<li><a href="https://benjaminlistwon.com/demo/dataflow/shared/index.html" target="_blank" rel="external">Using shared object</a></li>
<li><a href="https://benjaminlistwon.com/demo/dataflow/vuex/index.html" target="_blank" rel="external">Using vuex</a></li>
<li><a href="https://benjaminlistwon.com/demo/dataflow/evil/index.html" target="_blank" rel="external">Using evil bindings</a></li>
</ul>
<p>或者获取<a href="https://github.com/BenjaminListwon/vue-data-flow" target="_blank" rel="external">这个仓库</a>并在本地运行试试看！代码里很多地方是2.0版本的特性，但我接下来想讲的数据流概念在任何版本里都是相关的，并且它可以通过一些改变很轻易地向下兼容到1.0。</p>
<p>这些演示都是一样的功能，只是实现的方法不同。应用程序由两个独立的聊天组件实例组成。当用户在一个实例里提交一个消息的时候，它应该在两个聊天窗口都出现，因为消息状态是共享的，下面是一个截图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/662490-29fd9d48c9c1632c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="用一个对象共享状态"><a href="#用一个对象共享状态" class="headerlink" title="用一个对象共享状态"></a>用一个对象共享状态</h2><p>开始前，让我们先来看看数据是如何在示例的应用程序当中流转的。</p>
<p><img src="https://benjaminlistwon.com/postimg/data-flow-in-vue-and-vuex/shared-state-01.svg" alt=""></p>
<p>在这个演示里，我们将使用一个简单的 JavaScript 对象：<code>var store = {...}</code>，在<code>Client.vue</code>组件的实例之间共享状态。下面是关键文件的重要代码部分：</p>
<h5 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">  var store = &#123;</div><div class="line">    state: &#123;</div><div class="line">      messages: []</div><div class="line">    &#125;,</div><div class="line">    newMessage (msg) &#123;</div><div class="line">      this.state.messages.push(msg)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这里有两个关键的地方：</p>
<ol>
<li>我们通过把这个对象直接添加到<code>index.html</code>里来让其对整个应用程序可用，也可以将它注入到应用程序里更下一层的作用链，但目前直接添加显然更快捷简单。</li>
<li>我们在这里保存状态，但同时也提供了一个函数来调用它。相比起分散在组件各处的函数，我们更倾向于让它们保持在一个地方（便于维护），并在任何需要它们的地方简单使用。</li>
</ol>
<h5 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div id=&quot;app&quot;&gt;</div><div class="line">    &lt;div class=&quot;row&quot;&gt;</div><div class="line">      &lt;div class=&quot;col&quot;&gt;</div><div class="line">        &lt;client clientid=&quot;Client A&quot;&gt;&lt;/client&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">      &lt;div class=&quot;col&quot;&gt;</div><div class="line">        &lt;client clientid=&quot;Client B&quot;&gt;&lt;/client&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">import Client from &apos;./components/Client.vue&apos;</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">  components: &#123;</div><div class="line">    Client</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这里我们引入了 Client 组件，并创建了两个它的实例，使用一个属性：<code>clientid</code>，来对每个实例进行区分。事实上，你应该更动态地去实现这些，但别忘了，目前快捷简单更重要。</p>
<p>注意一点，到这里我们还完全没有同步任何状态。</p>
<h5 id="Client-vue"><a href="#Client-vue" class="headerlink" title="Client.vue"></a>Client.vue</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;h1&gt;&#123;&#123; clientid &#125;&#125;&lt;/h1&gt;</div><div class="line">    &lt;div class=&quot;client&quot;&gt;</div><div class="line">      &lt;ul&gt;</div><div class="line">        &lt;li v-for=&quot;message in messages&quot;&gt;</div><div class="line">          &lt;label&gt;&#123;&#123; message.sender &#125;&#125;:&lt;/label&gt; &#123;&#123; message.text &#125;&#125;</div><div class="line">        &lt;/li&gt;</div><div class="line">      &lt;/ul&gt;</div><div class="line">      &lt;div class=&quot;msgbox&quot;&gt;</div><div class="line">        &lt;input v-model=&quot;msg&quot; placeholder=&quot;Enter a message, then hit [enter]&quot; @keyup.enter=&quot;trySendMessage&quot;&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">export default &#123;</div><div class="line">  data() &#123;</div><div class="line">    return &#123;</div><div class="line">      msg: &apos;&apos;,</div><div class="line">      messages: store.state.messages</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  props: [&apos;clientid&apos;],</div><div class="line">  methods: &#123;</div><div class="line">    trySendMessage() &#123;</div><div class="line">      store.newMessage(&#123;</div><div class="line">        text: this.msg,</div><div class="line">        sender: this.clientid</div><div class="line">      &#125;)</div><div class="line">      this.resetMessage()</div><div class="line">    &#125;,</div><div class="line">    resetMessage() &#123;</div><div class="line">      this.msg = &apos;&apos;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>下面是应用程序的主要内容：</p>
<ol>
<li>在该模板里，设置一个<code>v-for</code>循环去遍历<code>messages</code>集合。</li>
<li>绑定在文本输入框上的<code>v-model</code>简单地存储了组件的本地数据对象<code>msg</code>。</li>
<li>同样在数据对象里，我们创建了一个<code>store.state.messages</code>的引用，它将触发组件的更新。</li>
<li>最后，将 enter 键绑定到<code>trySendMessage</code>函数，这个函数包含了以下几个功能：<ol>
<li>准备好需要存储的数据（发送者和消息的一个字典对象）。</li>
<li>调用定义在共享存储里的<code>newMessage</code>函数。</li>
<li>调用一个清理函数：<code>resetMessage</code>，重置输入框。通常你更应该在一个<code>promise</code>完成之后再调用它。</li>
</ol>
</li>
</ol>
<p>这就是使用对象的方法，来<a href="https://benjaminlistwon.com/demo/dataflow/shared/index.html" target="_blank" rel="external">试一试</a>。</p>
<h2 id="用-Vuex-共享状态"><a href="#用-Vuex-共享状态" class="headerlink" title="用 Vuex 共享状态"></a>用 Vuex 共享状态</h2><p>好了，现在来试试看用 Vuex 实现。同样的，先上图，也便于我们将 Vuex 的术语（actions，mutations等等）对应到我们刚刚完成的示例中。</p>
<p><img src="https://benjaminlistwon.com/postimg/data-flow-in-vue-and-vuex/vuex-01.svg" alt=""></p>
<p>正如你所看到的，Vuex 简单地形式化了我们刚刚完成的过程。使用它的时候，所做的事情其实和我们上面做过的非常像：</p>
<ol>
<li>创建一个用来共享的存储，在这个例子中它将通过 vue/vuex 注入到组件当中。</li>
<li>定义组件可以调用的 actions，它们仍然是集中定义的。</li>
<li>定义实际接触存储状态的 mutations。我们这么做，actions 就可以形成不止一个 mutation，或者执行逻辑去决定调用哪一个 mutation。这意味着你再也不用担心组件当中的业务逻辑了，成功！</li>
<li>当状态更新时，任何拥有 getter，动态属性和映射到 store 的组件都会被立即更新。</li>
</ol>
<p>同样再来看看代码：</p>
<h5 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import store from &apos;./vuex/store&apos;</div><div class="line"></div><div class="line">new Vue(&#123; // eslint-disable-line no-new</div><div class="line">  el: &apos;#app&apos;,</div><div class="line">  render: (h) =&gt; h(App),</div><div class="line">  store: store</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这次，我们用 Vuex 创建了一个存储并将其直接传入应用程序当中，替代掉了之前<code>index.html</code>中的 <code>store</code> 对象。在继续之前，先来看一下这个存储：</p>
<h5 id="store-js"><a href="#store-js" class="headerlink" title="store.js"></a>store.js</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">export default new Vuex.Store(&#123;</div><div class="line"></div><div class="line">  state: &#123;</div><div class="line">    messages: []</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  actions: &#123;</div><div class="line">    newMessage (&#123;commit&#125;, msg) &#123;</div><div class="line">      commit(&apos;NEW_MESSAGE&apos;, msg)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  mutations: &#123;</div><div class="line">    NEW_MESSAGE (state, msg) &#123;</div><div class="line">      state.messages.push(msg)</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  strict: debug</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>和我们自己创建的对象非常相似，但是多了一个<code>mutations</code>对象。</p>
<h5 id="Client-vue-1"><a href="#Client-vue-1" class="headerlink" title="Client.vue"></a>Client.vue</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;row&quot;&gt;</div><div class="line">  &lt;div class=&quot;col&quot;&gt;</div><div class="line">    &lt;client clientid=&quot;Client A&quot;&gt;&lt;/client&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">  &lt;div class=&quot;col&quot;&gt;</div><div class="line">    &lt;client clientid=&quot;Client B&quot;&gt;&lt;/client&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>和上次一样的配方。（惊人的相似，对吧？）</p>
<h5 id="Client-vue-2"><a href="#Client-vue-2" class="headerlink" title="Client.vue"></a>Client.vue</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">import &#123; mapState, mapActions &#125; from &apos;vuex&apos;</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">  data() &#123;</div><div class="line">    return &#123;</div><div class="line">      msg: &apos;&apos;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  props: [&apos;clientid&apos;],</div><div class="line">  computed: &#123;</div><div class="line">    ...mapState(&#123;</div><div class="line">      messages: state =&gt; state.messages</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    trySendMessage() &#123;</div><div class="line">      this.newMessage(&#123;</div><div class="line">        text: this.msg,</div><div class="line">        sender: this.clientid</div><div class="line">      &#125;)</div><div class="line">      this.resetMessage()</div><div class="line">    &#125;,</div><div class="line">    resetMessage() &#123;</div><div class="line">      this.msg = &apos;&apos;</div><div class="line">    &#125;,</div><div class="line">    ...mapActions([&apos;newMessage&apos;])</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>模板仍然刚好一样，所以我甚至不需要费心怎么去引入它。最大的不同在于：</p>
<ol>
<li>使用<code>mapState</code>来生成对共享消息集合的引用。</li>
<li>使用<code>mapActions</code>来生成创建一个新消息的动作（action）。</li>
</ol>
<p>(<strong>注意</strong>：这些都是 Vuex 2.0特性。)</p>
<p>好的，做完啦！也来看一下<a href="https://benjaminlistwon.com/demo/dataflow/vuex/index.html" target="_blank" rel="external">这个演示</a>吧。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>所以，正如你所希望看到的，自己进行简单的状态共享和使用 Vuex 进行共享并没有多大区别。而 Vuex <strong>最大的</strong>优点在于它为你形式化了集中处理数据存储的过程，并提供了所有功能方法去处理那些数据。</p>
<p>最初，当你阅读 Vuex 的文档和示例的时候，它那些针对 mutations，actions 和 modules 的单独文档很容易让人感觉困扰。但是如果你敢于跨出那一步，简单地在<code>store.js</code>文件里写一些关于它们的代码来开始学习。随着这个文件的大小增加，你就将找到正确的时间移步到<code>actions.js</code>里，或者是把它们更进一步地分离开来。</p>
<p>不要着急，慢慢来，一步一个台阶。当然也可以使用<a href="https://github.com/vuejs/vue-cli" target="_blank" rel="external">vue-cli</a>从创建一个模板开始，我使用<a href="https://github.com/vuejs-templates/browserify" target="_blank" rel="external">browserify</a>模板，并把下面的代码添加进我的<code>package.json</code>文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;dependencies&quot;: &#123;</div><div class="line">    &quot;vue&quot;: &quot;^2.0.0-rc.6&quot;,</div><div class="line">    &quot;vuex&quot;: &quot;^2.0.0-rc.5&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="还在看吗？"><a href="#还在看吗？" class="headerlink" title="还在看吗？"></a>还在看吗？</h2><p>我知道我还说过要再讲一个“不好的”方式。再次，这个演示恰好也是<a href="https://benjaminlistwon.com/demo/dataflow/evil/index.html" target="_blank" rel="external">一样</a>的。不好的地方在于我利用了 Vue 2.0 里单向绑定的特性来注入回调函数，从而允许了父子模板之间顺序的双向绑定。首先，来看一下<a href="http://rc.vuejs.org/guide/components.html#One-Way-Data-Flow" target="_blank" rel="external">2.0文档中的这个部分</a>，然后再来看看我这个不好的方法。</p>
<h5 id="App-vue-1"><a href="#App-vue-1" class="headerlink" title="App.vue"></a>App.vue</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;row&quot;&gt;</div><div class="line">  &lt;div class=&quot;col&quot;&gt;</div><div class="line">    &lt;client clientid=&quot;Client A&quot; :messages=&quot;messages&quot; :callback=&quot;newMessage&quot;&gt;&lt;/client&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">  &lt;div class=&quot;col&quot;&gt;</div><div class="line">    &lt;client clientid=&quot;Client B&quot; :messages=&quot;messages&quot; :callback=&quot;newMessage&quot;&gt;&lt;/client&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>这里，我在组件上使用了一个属性将一个动态绑定传递到<code>messages</code>集合里。<strong>但是</strong>，我同时还传递了一个动作函数，所以可以在子组件里调用它。</p>
<h5 id="Client-vue-3"><a href="#Client-vue-3" class="headerlink" title="Client.vue"></a>Client.vue</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">export default &#123;</div><div class="line">  data() &#123;</div><div class="line">    return &#123;</div><div class="line">      msg: &apos;&apos;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  props: [&apos;clientid&apos;, &apos;messages&apos;, &apos;callback&apos;],</div><div class="line">  methods: &#123;</div><div class="line">    trySendMessage() &#123;</div><div class="line">      this.callback(&#123;</div><div class="line">        text: this.msg,</div><div class="line">        sender: this.clientid</div><div class="line">      &#125;)</div><div class="line">      this.resetMessage()</div><div class="line">    &#125;,</div><div class="line">    resetMessage() &#123;</div><div class="line">      this.msg = &apos;&apos;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这里就是不好的做法。</p>
<p>要问为什么有这么不好吗？</p>
<ol>
<li>我们正在破坏之前图中所展示的单向循环。</li>
<li>我们创建了一个在组件及其父组件之间的紧密耦合。</li>
<li>这将变得<strong>不可</strong>维护。如果你在组件里需要20个函数，你就将添加20个属性，管理它们的命名等等，然后，如果任何东西发生改变，呃！</li>
</ol>
<p>所以为什么还要再展示这段？因为我和其他人一样很懒。有时我就会做这样的事情，仅仅想知道再继续做下去会有多么糟糕，然后我就会咒骂自己的懒惰，因为我可能要花上一小时或者一天的时间去清理它们。鉴于这种情况，我希望我可以帮助你尽早避免无谓的决定和错误，<strong>千万不要</strong>传递任何你不需要的东西。99%的情况下，一个单独的共享状态已经足够完美。（不久再详细讲讲那1%的情况）</p>
]]></content:encoded>
      
      <comments>http://llp0574.github.io/2016/10/14/data-flow-in-vue-and-vuex/#disqus_thread</comments>
    </item>
    
    <item>
      <title>用心设计的艺术</title>
      <link>http://llp0574.github.io/2016/09/12/the-art-of-designing-with-heart/</link>
      <guid>http://llp0574.github.io/2016/09/12/the-art-of-designing-with-heart/</guid>
      <pubDate>Mon, 12 Sep 2016 14:59:33 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://m.signalvnoise.com/the-art-of-designing-with-heart-f5dc4df21697?swoff=true#.bwkktzgf7&quot; target=&quot;_
      
      </description>
      
      <content:encoded><![CDATA[<blockquote>
<ul>
<li>原文地址：<a href="https://m.signalvnoise.com/the-art-of-designing-with-heart-f5dc4df21697?swoff=true#.bwkktzgf7" target="_blank" rel="external">The Art of Designing With Heart</a></li>
<li>原文作者：<a href="https://m.signalvnoise.com/@jonasdowney" target="_blank" rel="external">Jonas Downey</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="external">掘金翻译计划</a></li>
<li>译者：<a href="https://github.com/llp0574" target="_blank" rel="external">llp0574</a></li>
<li>校对者：<a href="https://github.com/Graning" target="_blank" rel="external">Graning</a>,<a href="https://github.com/cyseria" target="_blank" rel="external">cyseria</a></li>
</ul>
</blockquote>
<p>我喜爱软件开发的其中一个原因在于，它是一种深入的脑力锻炼，充满着令人兴奋的过程、各种抽象思想以及错综复杂的关联关系。</p>
<p>你可以用诸如 IT 研究、策略、原型、编程、UI、运营等更多这些实际性的具体细节来丰富自己。</p>
<p>如果这些都还不够呢？那就让自己尽情追求各项指标和性能吧。每一个最后的细节都可以被测试、量化以及优化，从而达到最完整的状态。努力提高各项 KPI（业务关键指标）并紧盯你的 ROI（投资回报率）吧！</p>
<p>问题在于：有这么多事情去考虑，以及这么多逻辑去操心，那么就很容易忘记你开发软件的初心：</p>
<h3 id="🚨️-你的软件的存在是为了帮助人们！🚨"><a href="#🚨️-你的软件的存在是为了帮助人们！🚨" class="headerlink" title="🚨️ 你的软件的存在是为了帮助人们！🚨"></a>🚨️ 你的软件的存在是为了帮助人们！🚨</h3><p>设计师们通常把这个概念称为<strong>用户体验</strong>或者<strong>用户心理</strong>。我认为这些称谓很糟糕，它们都过于套话和含糊，在不同的环境下可以有着不同的意思。</p>
<p>但我认为它真正是什么我们就应该称作什么：<strong>用心设计</strong>。</p>
<p>这并不是某个在你的公司里一个特定小组的职责，或者在一个过程当中你可以检查的某一步骤，它是一个会告诉你做每一个决策的核心价值。</p>
<hr>
<p>下面将说明它在实践中意味着什么。</p>
<p>在所有的策略、指标和技术的另外一端面临的是<strong>真实的人</strong>，这些人生存、呼吸，忙于处理他们各自稀奇古怪的生活琐事，和他们的小孩争论，试图弄清晚饭要吃什么。</p>
<p>当开发软件的时候，不免你会站在自己的角度发明一种机器，假设用户的感受，并以自己为代表用户模拟人机交互好让它们能有意义地实现某些功能。</p>
<p>你的软件不仅仅只是杂糅在一起的一堆代码和 UI。它还是你的最佳想法、最佳意图、帮助他人的渴望、你的爱、感受和灵魂的一个编译结果。</p>
<p>你的软件就是你自己。</p>
<p>（如果你相信它的艺术，那它就是，并且如果你做的是对的话那就更应该是了。）</p>
<hr>
<p>当你从这个角度看待软件的时候，就将注意到大量的软件其实是无聊且缺乏生命力的。</p>
<p>仔细想想你经常登录的银行网站，或者你的保险公司的账单系统，它们大概都是冰冷且没有生命力的。那是因为这些设计师都把他们的工作当作了一种机械操作：接受一组需求、创造想象的人物、写用户故事以及在需求到来前混混他们的工作。这些都是机械的工作，没有用心。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/662490-c18c85a6d02a50e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Capital One 的登录页面</p>
<p>现在，你可能会认为对于一个银行网站来说，看起来简单朴素且属于交易型并没什么问题。毕竟，银行业不夸张地说就是<strong>一组组交易的集合</strong>。</p>
<p>但相比起你可能曾经遇到过很体贴的银行柜员带来的体验（如果你仍然记得那是怎么样的一种体验），柜员对你微笑，询问你今天过得怎么样，仔细检查你的账目是正确的，为你可能忘记的事情提供帮助以及送你一根棒棒糖！🍭</p>
<p>这就是用了一点心思的交易过程。</p>
<hr>
<p>好了，接下来讲一下我们的软件如何来替代银行柜员。这意味着软件在理想情况下，应该提供同样的人性化和真正有帮助的服务。但怎么做呢？</p>
<p>选项之一是将对外接口拟人化并为软件赋予一些<a href="http://alistapart.com/article/personality-in-design" target="_blank" rel="external">个性</a>，这么做就可以让 UI 变得有趣、友好、智能、带有批判性或者卡通化。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/662490-428b645bfe2875e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>Poncho 生动的天气猫给你发送 “Zzz Zzzzzzz” 和 “Purrrrrrrrrrrrr.” 的信息</p>
<p>我认为这只是其中一小部分，因为人们对胡说八道的忍耐力很低。除非你能<strong>真正</strong>起到好的作用，否则好玩和有趣的东西将会很快变得让人恼火不已，甚至比机械化还要糟糕，因为它很浪费时间，开门见山往往会更好。</p>
<p>所以如果机械化不好，做的个性化也不好，那么什么是好的呢？</p>
<p>最佳选择则是两者适中。好的软件是友好、随性以及容易上手的，但同时也是严格、亲切以及有礼貌的。就像你曾经在本地交易中体验过的的一次舒适的真实生活经验。</p>
<hr>
<p>要实现这样听起来很困难（确实也是），但有一个简单的技巧可以帮上很多忙。</p>
<p><strong>当你设计某样东西的时候，想象你坐在一个房间里，正手把手地帮助真实的人解决问题。</strong>你将会对他们说些什么？你会怎么解释这个页面或特性？你会给出什么建议？你将告诉他们什么去进行下一步操作？</p>
<p>大声说出这些答案来，然后写下你所说的。现在你就已经完成80%了！</p>
<p>如果你正在亲自帮助某人，你肯定不会很严格或者拘谨，不会使用流行语、术语或一些商业辞令，你也不会向他们丢什么开玩笑的炸弹或者用旁边的高飞（迪士尼角色）来让他们分心。你肯定会观察他们在做什么，看看他们哪里遇到了困难，并帮助他们解决。<strong>你将用心和他们交流。</strong></p>
<hr>
<p>这个常识性的技巧可以让你不会只见树木不见森林。如果你费尽心思解释某样事情，那么可能往往还解释得不清楚。这个观点会让你问出类似下面的这些问题：</p>
<ul>
<li>我们可以让这个接口变得更简单或者更直接吗？</li>
<li>我们可以减少或者去掉这些用户必要的选择吗？</li>
<li>我们有没有用自然、随性的语言来充分解释这些操作？</li>
<li>这个设计有没有充分利用用户的时间和注意力？</li>
<li>这是一个我个人来说会很享受使用过程的东西吗？</li>
<li>我们有没有采取一些捷径让我们而不是他们受益？</li>
<li>我们有没有作出一些不正确的假设？</li>
</ul>
<p>现在你的设计完成后肯定更加清楚和友好。这就会让你的消费者更加开心并且更高效率，那么他们就可以停止摆弄软件，然后回去和他们那好争论的小孩继续吃晚饭了。</p>
<p><strong>这应该成为你工作的潜在动力。</strong>不是技术，不是样式，不是数据，也不是金钱。帮助人们是首要的，其他的都是次要的。</p>
<hr>
<p><strong>用心设计</strong>不仅仅只是创造一个产品。它同样可以指导你去营销、做广告以及销售。</p>
<p>比如说，你想要为你的产品增加付费用户。（谁不想？）这是一个商业为先的问题，不是一个用户为先的问题。</p>
<p>如果你仅仅考虑商业为先，你可能会发出一大堆促销邮件，或者在页面上到处展示 “BUY NOW” 入口，或者用弹窗广告去打断他们的关键工作流。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/662490-252fed8f8e3414e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>Wall Street Journal 甚至在你进入页面之前就弹窗询问你是否购买</p>
<p>这些技巧或许对增加业务指标有所帮助，但它们对消费者来说却是恼人和讨厌的。这并不是我们想要的结果。那我们怎么来解决两者之间的冲突呢？</p>
<p>简单：再次考虑用户！</p>
<p>清楚地传达产品的价格、让其变得更容易购买、给新用户传播你的信息甚至寻求推荐或点评，这些本来就不是一件坏事情 — 只要你这么做的方式考虑周全、诚实并且在对的时间去做，就没问题了。</p>
<p>不要在用户处理事情的中途去打断他们，不间断地去骚扰他们，或者强行去推销你想的主意。如果想要得到青睐，那么就该考虑清楚去解释为什么你需要他们的帮助，从而让他们的时间变得有价值，同时或许应该在交易过程中提出激励。</p>
<p>遵循这些方法，你的推销将会是一个双赢的结果。</p>
<hr>
<p>还有一件事情可以让你做到用心设计：<strong>不要害怕去展现自己。</strong></p>
<p>人们会和其他非人类机器建立起情绪化的连接。</p>
<p>当你的消费者可以看到是谁在背后和其交流，并且当你诚实可靠地和他们交流时，他们就将更加可能确认你的信息和入口。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/662490-5e4751262dbf1b66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>Nate Kontny’s Highrise更新总会有一个人性化提示。</p>
<p>如果你创造某个东西是因为你从根本上在意如何帮助用户，并且想要留住他们，那么就更应该说出来了！把你的名字放上去、讲述你的故事、展示你的形象并站出来为你的工作负责。分享你<strong>真实的</strong>个性肯定比捏造一个虚假的形象放在一个死气沉沉的应用上要好得多。</p>
<p>你的消费者将会以同样的方式作出回应，并且这就是所有回报里最有价值的东西。💞</p>
<hr>
]]></content:encoded>
      
      <comments>http://llp0574.github.io/2016/09/12/the-art-of-designing-with-heart/#disqus_thread</comments>
    </item>
    
    <item>
      <title>iOS 开发，该如何解决弹窗的设计问题？</title>
      <link>http://llp0574.github.io/2016/07/28/popovers-on-popovers/</link>
      <guid>http://llp0574.github.io/2016/07/28/popovers-on-popovers/</guid>
      <pubDate>Thu, 28 Jul 2016 14:44:57 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接: &lt;a href=&quot;https://pspdfkit.com/blog/2016/popovers-on-popovers/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Preventing Popovers on P
      
      </description>
      
      <content:encoded><![CDATA[<blockquote>
<p>原文链接: <a href="https://pspdfkit.com/blog/2016/popovers-on-popovers/" target="_blank" rel="external">Preventing Popovers on Popovers</a><br>原文作者: <a href="https://twitter.com/qdoug" target="_blank" rel="external">Douglas Hill</a><br>译文出自: <a href="https://github.com/xitu/gold-miner" target="_blank" rel="external">掘金翻译计划</a><br>译者:  <a href="https://github.com/llp0574" target="_blank" rel="external">llp0574</a><br>校对者: <a href="https://github.com/yifili09" target="_blank" rel="external">yifili09</a>,<a href="https://github.com/Graning" target="_blank" rel="external">Graning</a><br>译者注：转载请保留此头部。</p>
</blockquote>
<p>iOS 9 的页面用了一种我们不能复现的方式去展示一个活动视图控制器，并且当从内部表单和弹窗呈现操作列表和活动视图控制器时 UIKit 的行为一开始看起来不那么连贯。我们提交了两份 Radars 给苹果：<a href="http://openradar.appspot.com/27448912" target="_blank" rel="external">rdar://27448912 Can’t show activity view controller filling a form sheet</a> 和 <a href="http://openradar.appspot.com/27448488" target="_blank" rel="external">rdar://27448488 Reading an alert controller’s popoverPresentationController property changes behavior</a>。</p>
<p><a href="https://developer.apple.com/ios/human-interface-guidelines/interaction/modality/" target="_blank" rel="external">iOS 的人机交互指南</a>声明：</p>
<blockquote>
<p><strong>不要在一个弹窗上展示一个模态视图。</strong> 由于一个警告弹窗可能是一个异常，所以不应该在这上面展现任何东西。极少数情况下，当你真的需要在一个动作导致弹窗后展示一个模态视图时，应该先把弹窗关闭掉再进行展示。</p>
</blockquote>
<p><a href="https://developer.apple.com/ios/human-interface-guidelines/ui-views/popovers/" target="_blank" rel="external">并且</a>:</p>
<blockquote>
<p><strong>一次只展示一个弹窗。</strong> 展示多个弹窗会让交互变得杂乱并让人产生疑惑。千万不要展示一个级联或者有层次结构的弹窗，一个从另一个里面产生的那种。如果你需要展示一个新的弹窗，首先关闭已经弹出的那个。</p>
</blockquote>
<p>在横向水平的普通环境和全屏紧凑的环境下具有<a href="https://developer.apple.com/reference/uikit/uimodalpresentationstyle/1621382-popover" target="_blank" rel="external">弹窗</a>样式的视图控制器都应该呈现为弹窗。具有操作列表样式的 <a href="https://developer.apple.com/reference/uikit/uiactivityviewcontroller" target="_blank" rel="external"><code>UIActivityViewController</code></a> 和 <a href="https://developer.apple.com/reference/uikit/uialertcontroller" target="_blank" rel="external"><code>UIAlertController</code></a> 都遵守相同的规则：展示为弹窗或者一个上拉式表。所以如果一个弹窗展示一个活动视图控制器或者一个操作列表到底会发生什么？这个人机交互指南文档的说法好像有点矛盾。</p>
<p>在 iOS 9 页面的一个相关说明里，我们注意到在一个表单的视图控制器展示了一个填充了这个表单的 <a href="https://developer.apple.com/reference/uikit/uiactivityviewcontroller" target="_blank" rel="external"><code>UIActivityViewController</code></a>，想知道这是不是一个我们之前没有留意到的默认行为呢？又或者它是不是一个我们可以自定义实现的东西？</p>
<p><img src="https://pspdfkit.com/images/blog/2016/popovers-on-popovers/pages-sheet-in-form-sheet-59e3007e.jpg" alt="Screen shot of Pages on iPad showing an activity view controller presented as a sheet inside a form sheet"></p>
<p>对于大多数视图控制器来说，在里面展示一个弹窗或者表单需要将当前视图控制器的 <a href="https://developer.apple.com/reference/uikit/uimodalpresentationstyle" target="_blank" rel="external"><code>modalPresentationStyle</code></a> 设置为 <a href="https://developer.apple.com/reference/uikit/uimodalpresentationstyle/1621493-currentcontext" target="_blank" rel="external"><code>currentContext</code></a> 或者 <a href="https://developer.apple.com/reference/uikit/uimodalpresentationstyle/1621507-overcurrentcontext" target="_blank" rel="external"><code>overCurrentContext</code></a>。但对于某些像 <a href="https://developer.apple.com/reference/uikit/uiactivityviewcontroller" target="_blank" rel="external"><code>UIActivityViewController</code></a> 和 <a href="https://developer.apple.com/reference/uikit/uialertcontroller" target="_blank" rel="external"><code>UIAlertController</code></a> 这种 UIKit 提供的视图控制器来说，它们已经被赋予了自己的样式，<a href="https://developer.apple.com/reference/uikit/uimodalpresentationstyle" target="_blank" rel="external"><code>modalPresentationStyle</code></a> 的变化将被忽略掉。</p>
<p>一般，<a href="https://developer.apple.com/reference/uikit/uiactivityviewcontroller" target="_blank" rel="external"><code>UIActivityViewController</code></a> 会在常规宽度下展示为弹窗，在紧凑宽度下变成一个透明的表。但是如果一个常规宽度的视图控制器要从一个紧凑宽度的视图控制器里展示会怎么样呢？这种情况会在一个有<a href="https://developer.apple.com/reference/uikit/uimodalpresentationstyle/1621491-formsheet" target="_blank" rel="external">表格</a>或者<a href="https://developer.apple.com/reference/uikit/uimodalpresentationstyle/1621382-popover" target="_blank" rel="external">弹窗</a> 的 <a href="https://developer.apple.com/reference/uikit/uimodalpresentationstyle" target="_blank" rel="external"><code>modalPresentationStyle</code></a> 的视图控制器要在 iPad 上展示，或者它是一个使用了 <a href="https://developer.apple.com/reference/uikit/uipresentationcontroller/1618335-overridetraitcollection" target="_blank" rel="external"><code>overrideTraitCollection</code></a> 属性的自定义展示控制器，然后这个控制器展示了一个 <a href="https://developer.apple.com/reference/uikit/uiactivityviewcontroller" target="_blank" rel="external"><code>UIActivityViewController</code></a>。</p>
<p><img src="https://pspdfkit.com/images/blog/2016/popovers-on-popovers/diagram-23ed42d7.png" alt="Diagram: First View Controller to Second View Controller to Activity View Controller or Action Sheet"></p>
<h2 id="操作列表"><a href="#操作列表" class="headerlink" title="操作列表"></a>操作列表</h2><p>首先我们来看看 <a href="https://developer.apple.com/reference/uikit/uialertcontroller" target="_blank" rel="external"><code>UIAlertController</code></a>。图中根视图控制器（青色）用<a href="https://developer.apple.com/reference/uikit/uimodalpresentationstyle/1621382-popover" target="_blank" rel="external">弹窗</a>样式（下方，通过切分视图行为以作参考）展示了第二个用<a href="https://developer.apple.com/reference/uikit/uimodalpresentationstyle/1621491-formsheet" target="_blank" rel="external">表单</a>样式（上方）的视图控制器（粉色）。然后第二个视图控制器展示了一个操作列表样式的警告控制器。</p>
<p><img src="https://pspdfkit.com/images/blog/2016/popovers-on-popovers/form-sheet-action-popover-c90794ab.jpg" alt="Form sheet presenting action sheet as popover"> <img src="https://pspdfkit.com/images/blog/2016/popovers-on-popovers/popover-action-popover-fca43393.jpg" alt="Popover presenting action sheet as popover"></p>
<p>虽然我们想要用列表的展示样式去展示操作列表（而不是弹窗），但因为关注点分离的优势，我设置了警告控制器的 <a href="https://developer.apple.com/reference/uikit/uipopoverpresentationcontroller/1622313-sourceview" target="_blank" rel="external"><code>popoverPresentationController.sourceView</code></a> 和 <a href="https://developer.apple.com/reference/uikit/uipopoverpresentationcontroller/1622324-sourcerect" target="_blank" rel="external"><code>popoverPresentationController.sourceRect</code></a>，视图控制器不应该对它怎么展示作出假设。它应该在 app 的其他部分进行全屏展示，视图控制器不应该控制这些行为。</p>
<p>出于好奇，我尝试注释掉了<a href="https://developer.apple.com/reference/uikit/uiviewcontroller/1621428-popoverpresentationcontroller" target="_blank" rel="external"><code>popoverPresentationController</code></a>的定义，发生了让我意想不到的情况：</p>
<p><img src="https://pspdfkit.com/images/blog/2016/popovers-on-popovers/form-sheet-action-sheet-38753715.jpg" alt="Form sheet presenting action sheet as sheet"> <img src="https://pspdfkit.com/images/blog/2016/popovers-on-popovers/popover-action-sheet-2b011d4f.jpg" alt="Popover presenting action sheet as sheet"></p>
<p>原来只读取警告控制器的<a href="https://developer.apple.com/reference/uikit/uiviewcontroller/1621428-popoverpresentationcontroller" target="_blank" rel="external"><code>popoverPresentationController</code></a>属性会导致即使是从一个紧凑宽度环境下呈现它也会展示为一个弹窗。如果你想这么做，请一定要确保好视图控制器展现的前后环境，因为如果你想从常规宽度的环境展现一个没有设置弹窗源码的警告控制器，UIKit 就会抛出一个异常。切记在展现触发的时候即使呈现视图控制器是在一个紧凑宽度环境下，当展示被激活的时候它还是有可能发生改变。</p>
<p>我提交了一个 <a href="http://openradar.appspot.com/27448488" target="_blank" rel="external">rdar://27448488 Reading an alert controller’s popoverPresentationController property changes behavior</a>.</p>
<h2 id="活动视图控制器"><a href="#活动视图控制器" class="headerlink" title="活动视图控制器"></a>活动视图控制器</h2><p>用<a href="https://developer.apple.com/reference/uikit/uiactivityviewcontroller" target="_blank" rel="external"><code>UIActivityViewController</code></a>做同样的事情，并指定弹窗源码信息，出现下面的情况：</p>
<p><img src="https://pspdfkit.com/images/blog/2016/popovers-on-popovers/form-sheet-activity-318dfc25.jpg" alt="Form sheet presenting activity view controller as a popover"> <img src="https://pspdfkit.com/images/blog/2016/popovers-on-popovers/popover-activity-4bde59d8.jpg" alt="Popover presenting activity view controller as a sheet"></p>
<p>不同于页面的行为，我发现表单把这个活动视图控制器展示为一个弹窗，弹窗将活动视图控制器展示在表单上。这是在 iOS 10 的新行为，iOS 9 里，是从另一个弹窗展示一个弹窗。</p>
<p>用同样不访问<a href="https://developer.apple.com/reference/uikit/uiviewcontroller/1621428-popoverpresentationcontroller" target="_blank" rel="external"><code>popoverPresentationController</code></a>的技巧导致 UIKit 抛出一个异常说“必须为这个弹窗提供位置信息”。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们发现当 UIKit 的视图控制器是从一个展示在常规宽度环境的紧凑宽度的环境中展示时行为会变得很混乱。弹窗展现的一般规则是在常规宽度下展示为弹窗，在紧凑宽度下为全屏（尽管结合当前上下环境更有意义）。操作列表和活动视图控制器的展示有点像弹窗的展示，但不要完全按照一般的规则来展示。</p>
<p>实际的行为看起来像是和人机交互指南说的一样，并很大程度上忽略了特征集合的 Size 类。UIKit 不会在操作列表的异常警告上展现一个弹窗。Size 类并不能控制所有的东西。</p>
<p>我们不能重现页面(Pages)的行为。对于我们来说，当一个表单展示一个活动视图控制器时，它将展示为弹窗。我把这个问题报告给了 Apple ：<a href="http://openradar.appspot.com/27448912" target="_blank" rel="external">rdar://27448912 Can’t show activity view controller filling a form sheet</a>。如果你知道解决这个问题的方法，<a href="https://twitter.com/qdoug" target="_blank" rel="external">麻烦在我的 Twitter 留言</a>。</p>
]]></content:encoded>
      
      <comments>http://llp0574.github.io/2016/07/28/popovers-on-popovers/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何使用 TypeScript 编写 AngularJS 的 Controller？</title>
      <link>http://llp0574.github.io/2016/07/27/use-typescript-to-write-angular-controller/</link>
      <guid>http://llp0574.github.io/2016/07/27/use-typescript-to-write-angular-controller/</guid>
      <pubDate>Wed, 27 Jul 2016 14:28:13 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接 : &lt;a href=&quot;http://www.siddharthpandey.net/how-to-write-angularjs-controller-using-typescript/&quot; target=&quot;_blank&quot; rel=&quot;ext
      
      </description>
      
      <content:encoded><![CDATA[<blockquote>
<p>原文链接 : <a href="http://www.siddharthpandey.net/how-to-write-angularjs-controller-using-typescript/" target="_blank" rel="external">How to write AngularJS controller using TypeScript?</a><br>原文作者 : <a href="http://www.siddharthpandey.net/" target="_blank" rel="external">Siddharth Pandey</a><br>译者 : <a href="https://github.com/llp0574" target="_blank" rel="external">llp</a>（web前端领域）<br>译者注：翻译如有疏漏，欢迎指出！感谢！转载请保留此头部。</p>
</blockquote>
<p>AngularJS 有许多强大的特性，其中之一便是 Controller。在这篇文章里，我将介绍如何使用 TypeScript 去编写 AngularJS 的 Controller。</p>
<p>Controller 通常用来增强 <a href="https://docs.angularjs.org/guide/scope" target="_blank" rel="external">AngularJS 作用域（Scope）</a>。当一个 Controller 通过 <code>ng-controller</code> 指令连接到 DOM 上的时候，Angular 将使用指定的 Conroller 函数初始化一个新的 Controller 对象。一个新的子 scope 将被创建并作为 <code>$scope</code> 变量注入到 Controller 的构造函数当中。</p>
<p>有两个选项将 Controller 连接到视图当中，一种是 Controller 作为语法，另外一种是使用 <code>$scope</code>。如果使用 Controller 语法，Controller 实例将被分配一个在新作用域上的属性。</p>
<p>要想知道类型定义，看看<a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="external">这个令人吃惊的仓库</a>，它收集了几乎所有流行的 JavaScript 库。这些类型定义可以让我们得到任何编译时错误和 <a href="https://en.wikipedia.org/wiki/Integrated_development_environment" target="_blank" rel="external">IDE</a> 的智能支持。我使用 Visual Studio 和 Visual Code，它们都对 TypeScript 有很好的支持。</p>
<p>正如上面提到的，AngularJS 只要在被请求的时候都将创建一个Controller 实例。所以，一个 Controller 可以使用 TypeScript 里的类去定义，就像我们所知道的，一个类是可以被实例化的。让我们来使用在视图里 Controller 作为语法的方法来定义一个 Dashboard Controller。下面的代码没有使用 <code>$scope</code> 服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">interface IDashboardVm &#123;</div><div class="line">    news: &#123; title: string, description: string &#125;;</div><div class="line">    messageCount: number;</div><div class="line">    people: Array&lt;any&gt;;</div><div class="line">    title: string;</div><div class="line">    getMessageCount: () =&gt; ng.IPromise&lt;number&gt;;</div><div class="line">    getPeople: () =&gt; ng.IPromise&lt;Array&lt;any&gt;&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class DashboardController implements IDashboardVm &#123;</div><div class="line">    static $inject: Array&lt;string&gt; = [&apos;dataservice&apos;];</div><div class="line">    constructor(private dataservice: app.core.IDataService) &#123;</div><div class="line">        this.getMessageCount();</div><div class="line">        this.getPeople();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    news = &#123;</div><div class="line">        title: &apos;News&apos;,</div><div class="line">        description: &apos;Internal server team is excited about AngularJS, TypeScript &amp; JavaScript&apos;</div><div class="line">    &#125;;</div><div class="line">    messageCount: number = 0;</div><div class="line">    people: Array&lt;any&gt; = [];</div><div class="line">    hubsSummary: Array&lt;any&gt; = [];</div><div class="line">    title: string = &apos;Dashboard&apos;;</div><div class="line"></div><div class="line">    getMessageCount() &#123;</div><div class="line">        return this.dataservice.getMessageCount().then((data) =&gt; &#123;</div><div class="line">            this.messageCount = data;</div><div class="line">            return this.messageCount;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getPeople() &#123;</div><div class="line">        return this.dataservice.getPeople().then((data) =&gt; &#123;</div><div class="line">            this.people = data;</div><div class="line">            return this.people;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">angular.module(&apos;app.dashboard&apos;).controller(&apos;DashboardController&apos;, DashboardController);</div></pre></td></tr></table></figure>
<p>利用 TypeScript 的强类型特征，最好创建一个包含所有和视图相关成员和行为的接口。这就可以使为一个 Controller 定义实现变得容易，而且这个接口如果需要就可以做成一个抽象方法在其他地方使用了。所以，上面代码里我创建了一个名为 <code>IDashboardVm</code> 的接口。</p>
<p>接着，名为 <code>DashboardController</code> 的 Controller 实现了这个接口并给每个成员定义了默认状态。看这个类的静态变量 <code>$inject</code>，它告诉了 <a href="https://docs.angularjs.org/guide/di" target="_blank" rel="external">AngularJS DI</a> 在初始化这个 Controller 之前注入哪些依赖。然后构造器在需要的依赖的相同顺序定义了参数当它们被注入到那些参数的时候。</p>
<p>类所提到的依赖都是相当直接了当的，假设 <code>dataservice</code> 是一个自定义的 AngularJS 服务，它封装了所有对服务器发起的 HTTP 请求。根据接口里的每个定义，接下来我们要为这些行为定义实现，内部调用 <code>dataservice</code> 方法。它使用了 <code>promises</code> 去返回待会儿要分配到 Controller 成员上去控制状态的响应。</p>
<p>真正重要的是要注意使用 Angular 的模块 API 注册这个 Controller 的位置。上面的代码里，首先定义了类然后完成其注册。如果这个顺序交换的话，Angular 就将找不到我们这个 Controller 的实现了。当使用一个 JavaScript 构造函数就可以很好地解决问题，因为<a href="http://code.tutsplus.com/tutorials/javascript-hoisting-explained--net-15092" target="_blank" rel="external">函数提升起到了很重要的作用</a>。</p>
<p>下面是这个 Controller 如何在 <a href="https://github.com/angular-ui/ui-router" target="_blank" rel="external">Angular-UI UI-Router</a> 中使用的代码片段，但如果你想使用 Angular 内置路由模块的话概念是一样的。注意，这只展示了使用 <code>controllerAs</code> 语法进行配置的部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">config: &#123;</div><div class="line">    url: &apos;/&apos;,</div><div class="line">    templateUrl: &apos;app/dashboard/dashboard.html&apos;,</div><div class="line">    controller: &apos;DashboardController&apos;,</div><div class="line">    controllerAs: &apos;vm&apos;,</div><div class="line">    title: &apos;dashboard&apos;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你想使用 <code>$scope</code> 服务的话，那么就可以像下面的代码片段那样扩展上面的接口。这将确保所有 IScope 有的成员可以通过接口访问到。使用这个方法还需要改变一下 Controller 类的实现，因为现在它需要 <code>$scope</code> 服务的依赖了。自定义接口类型接着就可以在构造器使用 <code>$scope</code> 参数获得强类型和智能支持了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">interface IDashboardVm extends angular.IScope &#123;</div><div class="line">    news: &#123; title: string, description: string &#125;;</div><div class="line">    messageCount: number;</div><div class="line">    people: Array&lt;any&gt;;</div><div class="line">    title: string;</div><div class="line">    getMessageCount: () =&gt; ng.IPromise&lt;number&gt;;</div><div class="line">    getPeople: () =&gt; ng.IPromise&lt;Array&lt;any&gt;&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你想学到更多有关如何整合 AngularJS 和 TypeScript 的知识，可以看看<a href="http://www.siddharthpandey.net/tag/angularjs/" target="_blank" rel="external">我的 AngularJS 文章</a>。如果你想学习其他一些特别的东西可以联系我，我会尝试写相关文章的。</p>
]]></content:encoded>
      
      <comments>http://llp0574.github.io/2016/07/27/use-typescript-to-write-angular-controller/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何使用 TypeScript 编写自定义 AngularJS 指令？</title>
      <link>http://llp0574.github.io/2016/07/26/use-typescript-to-write-angular-directive/</link>
      <guid>http://llp0574.github.io/2016/07/26/use-typescript-to-write-angular-directive/</guid>
      <pubDate>Tue, 26 Jul 2016 14:19:21 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接 : &lt;a href=&quot;http://www.siddharthpandey.net/how-to-write-custom-angularjs-directive-using-typescript/&quot; target=&quot;_blank&quot; re
      
      </description>
      
      <content:encoded><![CDATA[<blockquote>
<p>原文链接 : <a href="http://www.siddharthpandey.net/how-to-write-custom-angularjs-directive-using-typescript/" target="_blank" rel="external">How to write custom AngularJS Directive using TypeScript?</a><br>原文作者 : <a href="http://www.siddharthpandey.net/" target="_blank" rel="external">Siddharth Pandey</a><br>译者 : <a href="https://github.com/llp0574" target="_blank" rel="external">llp</a>（web前端领域）<br>译者注：翻译如有疏漏，欢迎指出！感谢！转载请保留此头部。</p>
</blockquote>
<p><a href="https://angularjs.org/" target="_blank" rel="external">AngularJS</a> 框架有很多强大的特性，其中指令(Directives)是广为人知的。在这篇文章中，我将告诉你如何用 TypeScript 编写自定义 AngularJS 指令。首先，我将讲一下关于指令的基本知识，但如果你想直接看 TypeScript 代码的，你可以<a href="https://segmentfault.com/a/1190000006075565#articleHeader4" target="_blank" rel="external">跳过基本</a>。</p>
<h3 id="什么是指令？"><a href="#什么是指令？" class="headerlink" title="什么是指令？"></a>什么是指令？</h3><blockquote>
<p>在较高层面上，指令是一个 DOM 元素的标记（像一个属性，元素名称，注释或者 CSS 类），它告诉 Angular 的 HTML 编译器（<code>$compiler</code>）去给 DOM 元素连接一个特殊的行为（例如通过事件监听），或者甚至是改变这个 DOM 元素和其子元素。</p>
<p>Angular 本身有一些内建的指令，像 <code>ngbind</code>,<code>ngModel</code>和 <code>ngClass</code>。就像你创建控制器（controllers）和服务（services）那样，你可以创建自己的指令给 Angular 使用。当 Angular <a href="https://docs.angularjs.org/guide/bootstrap" target="_blank" rel="external">启动</a>你的应用时，<a href="https://docs.angularjs.org/guide/compiler" target="_blank" rel="external">HTML 编译器</a>就会对 DOM 元素进行遍历找到符合的指令。</p>
<p>-<a href="https://docs.angularjs.org/guide/directive" target="_blank" rel="external">AngualrJS 文档</a></p>
</blockquote>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>看看<code>ng-controller</code>和<code>ng-bind</code>这些 AngularJS 框架自带指令的使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;div ng-controller=&quot;Controller&quot;&gt;</div><div class="line">  Hello &lt;input ng-model=&apos;name&apos;&gt; &lt;hr/&gt;</div><div class="line">  &lt;span data-ng-bind=&quot;name&quot;&gt;&lt;/span&gt; &lt;br/&gt;</div><div class="line">  &lt;span ng:bind=&quot;name&quot;&gt;&lt;/span&gt; &lt;br/&gt;</div><div class="line">  &lt;span ng_bind=&quot;name&quot;&gt;&lt;/span&gt; &lt;br/&gt;</div><div class="line">  &lt;span data-ng-bind=&quot;name&quot;&gt;&lt;/span&gt; &lt;br/&gt;</div><div class="line">  &lt;span x-ng-bind=&quot;name&quot;&gt;&lt;/span&gt; &lt;br/&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h3 id="标准化过程"><a href="#标准化过程" class="headerlink" title="标准化过程"></a>标准化过程</h3><p>上面的代码片段，有多种方式去标记一个指令。AngularJS 的 HTML 编译器负责决定哪个元素匹配哪个指令，一般通过区分大小写的 <code>camelCase</code>（驼峰式） 命名方法（如 <code>ngModel</code>）去使用指令。但是，因为 HTML 是不区分大小写的，一般我们使用小写形式的 <em>短横线-分隔</em> 属性写在 DOM 元素上（如<code>ng-model</code>）。</p>
<p>标准化过程如下：</p>
<ol>
<li>前面的元素或属性使用带<code>x-</code>或<code>data-</code>的形式。</li>
<li>将<code>:</code>,<code>-</code>或<code>_</code>这些分隔符转化为<code>camelCase</code>（驼峰式）。</li>
</ol>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>最好使用 <em>短横线-分隔</em> 格式（如 <code>ng-bind</code> 对应 <code>ngBind</code>）。如果你想使用一个 HTML 验证工具，可以使用 <em>带data前缀</em> 的版本进行替代（如 <code>data-ng-bind</code> 对应 <code>ngBind</code>）。上面展示的其他形式因遗留原因仍然可以使用当还是建议避免使用它们。</p>
<h3 id="指令的类型"><a href="#指令的类型" class="headerlink" title="指令的类型"></a>指令的类型</h3><p>AngularJS 的 HTML 编译器如<code>$compiler</code>可以基于元素名，属性，类名，还有注释去匹配指令。下面的例子展示了一个名为<code>myDir</code>的指令在一个 HTML 模板里是怎么用多种方式去引用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;my-dir&gt;&lt;/my-dir&gt;</div><div class="line">&lt;span my-dir=&quot;exp&quot;&gt;&lt;/span&gt;</div><div class="line">&lt;!-- directive: my-dir exp --&gt;</div><div class="line">&lt;span class=&quot;my-dir: exp;&quot;&gt;&lt;/span&gt;</div></pre></td></tr></table></figure>
<h4 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>最好通过标签名或者属性而不是注释和类名去使用指令。这样做通常会更容易去决定哪个指令匹配给定的元素。</p>
<p>注释指令通常在 DOM API 限制跨越多个元素创建指令的地方使用（如<code>table</code>元素）。AngularJS 1.2 采用了<code>ng-repeat-start</code>和<code>ng-repeat-end</code>作为解决这个问题更好的方法，鼓励开发者尽量使用这个方法代替注释指令。</p>
<h3 id="TypeScript-中的自定义指令"><a href="#TypeScript-中的自定义指令" class="headerlink" title="TypeScript 中的自定义指令"></a>TypeScript 中的自定义指令</h3><p>让我们来创建一个只为任何的块，小部件或者人名在右边添加标题，子标题和文本的指令。这是一个很好的例子，因为它可以在很多地方重用而且可以作为一个有隔离作用域的指令在每个动态加载的块中作为信息展示。</p>
<p>来看看 HTML，Typescript 的代码在其下方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;widget-head&quot;&gt;</div><div class="line">  &lt;div class=&quot;page-title pull-left&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;</div><div class="line">  &lt;small class=&quot;page-title-subtle&quot; ng-show=&quot;subtitle&quot;&gt;(&#123;&#123;subtitle&#125;&#125;)&lt;/small&gt;</div><div class="line">  &lt;div class=&quot;widget-icons pull-right&quot;&gt;&lt;/div&gt;</div><div class="line">  &lt;small class=&quot;pull-right page-title-subtle&quot; ng-show=&quot;rightText&quot;&gt;&#123;&#123;rightText&#125;&#125;&lt;/small&gt;</div><div class="line">  &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line"></div><div class="line">interface IHtWidgetHeaderScope &#123;</div><div class="line">  title: string;</div><div class="line">  subtitle: string;</div><div class="line">  rightText: string;</div><div class="line">  allowCollapse: string;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Usage:</div><div class="line">//&lt;div ht-widget-header title=&quot;vm.map.title&quot;&gt;&lt;/div&gt;</div><div class="line">// Creates:</div><div class="line">// &lt;div ht-widget-header=&quot;&quot;</div><div class="line">//      title=&quot;Movie&quot;</div><div class="line">//&lt;/div&gt;</div><div class="line">class HtWidgetHeader implements ng.IDirective &#123;</div><div class="line">  static $inject: Array&lt;string&gt; = [&apos;&apos;];</div><div class="line">  constructor() &#123; &#125;</div><div class="line"></div><div class="line">  static instance(): ng.IDirective &#123;</div><div class="line">    return new HtWidgetHeader();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  scope: IHtWidgetHeaderScope = &#123;</div><div class="line">    &apos;title&apos;: &apos;@&apos;,</div><div class="line">    &apos;subtitle&apos;: &apos;@&apos;,</div><div class="line">    &apos;rightText&apos;: &apos;@&apos;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">  templateUrl: string = &apos;app/widgets/widget-header.html&apos;;</div><div class="line">  restrict: string = &apos;EA&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">angular.module(&apos;app&apos;).directive(&apos;htWidgetHeader&apos;, HtWidgetHeader.instance);</div></pre></td></tr></table></figure>
<p>利用 TypeScript 的特点，创建一个定义了可在指令内使用的作用域成员的接口（interface）。同样地我们想创建一个指令的实例，我们就定义一个实现了<code>IDirective</code>的类（class）。</p>
<p>要想知道类型定义，看看<a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="external">这个令人吃惊的仓库</a>，它收集了几乎所有流行的 JavaScript 库。这些类型定义可以让我们得到任何编译时错误和 <a href="https://en.wikipedia.org/wiki/Integrated_development_environment" target="_blank" rel="external">IDE</a> 的智能支持。我使用 Visual Studio 和 Visual Code，它们都对 TypeScript 有很好的支持。</p>
<p>这个指令不需要任何内建的 angular 服务或任何依赖，所以 <code>$inject</code> 这个静态成员只是一个空数组。如果依赖被列出来的话，框架就会根据这个变量的内容去寻找然后依赖注入。</p>
<p>构造器（constructor）不用做什么事情但我们还是需要一个静态的 <code>instance</code> 方法去创建一个指令的实例。框架会在定义一个使用了模块指令 API 的时候期望一个指令的实例。</p>
<p>这个类的 <code>scope</code> 在这里非常重要，因为这个指令使用隔离的作用域，即它自身的成员变量可以在这个指令的模板当中使用但并不继承外层或其父级作用域的声明。为了可读性和可维护性，我们使用了 <code>templateUrl</code> 去指定模板的源码。另外，<code>restrict</code> 设置了指令的使用级别给元素和属性，分别使用 E 和 A 表示。</p>
<p><code>restrict</code> 选项一般设置为：</p>
<ul>
<li>‘A’：只匹配属性名</li>
<li>‘E’：只匹配元素名</li>
<li>‘C’：只匹配类名</li>
<li>‘M’：只匹配注释</li>
</ul>
<p>这些限制只要需要都可以结合：’AEC’ 匹配属性或元素或类名。</p>
<p>现在可以像下面的代码片段那样使用这个指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div ht-widget-header title=&quot;&#123;&#123;vm.title&#125;&#125;&quot; subtitle=&quot;&#123;&#123;vm.description&#125;&#125;&quot; right-text=&quot;&#123;&#123;vm.refreshedDateTimeInfo&#125;&#125;&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>这个指令可以在给到一个硬编码或者动态的 <code>title</code>，<code>subtitle</code> 或者 <code>right-text</code>作用域成员的情况下作为元素或者属性使用。注意到后者和任何指令一样都已经被编译器标准化。上面的代码片段在一个模板里使用，该模板链接到一个含有 <code>title</code>，<code>description</code> 和 <code>refreshedDateTimeInfo</code> 变量的控制器，然后展示给用户。给定一些标记和设计，就会像下面这样：</p>
<p><img src="http://i1.wp.com/www.siddharthpandey.net/wp-content/uploads/2016/04/Screen-Shot-2016-05-01-at-18.21.20.png?w=511" alt=""></p>
<p>如果你想学到更多有关如何整合 AngularJS 和 TypeScript 的知识，可以看看<a href="http://www.siddharthpandey.net/tag/angularjs/" target="_blank" rel="external">我的 AngularJS 文章</a>。如果你想学习其他一些特别的东西可以联系我，我会尝试写相关文章的。</p>
]]></content:encoded>
      
      <comments>http://llp0574.github.io/2016/07/26/use-typescript-to-write-angular-directive/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Controller间的数据共享？最佳实践：使用Service</title>
      <link>http://llp0574.github.io/2016/07/22/angular-controller-data-share/</link>
      <guid>http://llp0574.github.io/2016/07/22/angular-controller-data-share/</guid>
      <pubDate>Fri, 22 Jul 2016 14:14:08 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接 : &lt;a href=&quot;https://daveceddia.com/sharing-data-between-controllers-best-practice-use-a-service/&quot; target=&quot;_blank&quot; rel=&quot;e
      
      </description>
      
      <content:encoded><![CDATA[<blockquote>
<p>原文链接 : <a href="https://daveceddia.com/sharing-data-between-controllers-best-practice-use-a-service/" target="_blank" rel="external">Sharing Data Between Controllers? Best Practice: Use a Service</a><br>原文作者 : <a href="https://daveceddia.com/" target="_blank" rel="external">DAVE CEDDIA</a><br>译者 : <a href="https://github.com/llp0574" target="_blank" rel="external">llp</a>（web前端领域）<br>译者注：翻译如有疏漏，欢迎指出！感谢！转载请保留此头部。</p>
</blockquote>
<p>Angular开始起来简单易用，甚至说神奇。“哇哦！双向绑定！”</p>
<p>你会迫不及待地去构建你的杰作，直到碰到钉子：你正在像网上每个人建议的那样去构建一个独立的组件，但怎么和其他组件共享数据呢？</p>
<p>或许你在不同的路由里有两个视图都需要访问某些状态变量，又或者你有三个分离的组件需要访问同样的一堆数据。</p>
<p>共享数据的最佳策略是什么呢？用一些变态的控制器继承方案吗？</p>
<p>当然不是，最简单容易的方式就是<strong>使用服务</strong>（service）。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>假设有两个并排的面板，每个面板代表一个指令（directive）：</p>
<p><img src="https://daveceddia.com/images/two_panes@2x.png" alt=""></p>
<p>下面是面板1的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">angular.directive(&apos;paneOne&apos;, function() &#123;</div><div class="line">  return &#123;</div><div class="line">    restrict: &apos;E&apos;,</div><div class="line">    scope: &#123;&#125;,</div><div class="line">    template: [</div><div class="line">      &apos;&lt;div&gt;&apos;,</div><div class="line">        &apos;&lt;input ng-model=&quot;p1.text&quot;&gt;&apos;,</div><div class="line">        &apos;&lt;button ng-click=&quot;p1.addToList()&quot;&gt;Add To List&lt;/button&gt;&apos;,</div><div class="line">      &apos;&lt;/div&gt;&apos;</div><div class="line">    ].join(&apos;&apos;),</div><div class="line">    controllerAs: &apos;p1&apos;,</div><div class="line">    controller: function() &#123;</div><div class="line">      var vm = this;</div><div class="line">      vm.text = &quot;&quot;;</div><div class="line">      vm.addToList = function() &#123;</div><div class="line">        // TODO: add to the list in Pane 2 somehow</div><div class="line">        vm.text = &quot;&quot;;</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>面板2的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">angular.directive(&apos;paneTwo&apos;, function() &#123;</div><div class="line">  return &#123;</div><div class="line">    restrict: &apos;E&apos;,</div><div class="line">    scope: &#123;&#125;,</div><div class="line">    template: [</div><div class="line">      &apos;&lt;ul&gt;&apos;,</div><div class="line">        &apos;&lt;li ng-repeat=&quot;item in p2.listItems&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;&apos;,</div><div class="line">      &apos;&lt;/ul&gt;&apos;</div><div class="line">    ].join(&apos;&apos;),</div><div class="line">    controllerAs: &apos;p2&apos;,</div><div class="line">    controller: function() &#123;</div><div class="line">      var vm = this;</div><div class="line">      // TODO: get this list of items from Pane 1 somehow</div><div class="line">      vm.listItems = [];</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们想要实现的是在面板1的输入框中输入某些东西，然后点击按钮 “Add To List”, 这条内容就会在面板2的列表中出现。</p>
<h3 id="创建一个服务保持共享状态"><a href="#创建一个服务保持共享状态" class="headerlink" title="创建一个服务保持共享状态"></a>创建一个服务保持共享状态</h3><p>为了在两个甚至更多的控制器间共享数据，创建一个服务去扮演中间件的角色。这样可以使控制器（或组件）保持松散耦合：它们不需要知道其他的控制器（或组件）是怎么样的，它们只需要知道数据源 - 你创建的中间件服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">angular.factory(&apos;sharedList&apos;, function() &#123;</div><div class="line">  var list = [];</div><div class="line"></div><div class="line">  return &#123;</div><div class="line">    addItem: addItem,</div><div class="line">    getList: getList</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  function addItem(item) &#123;</div><div class="line">    list.push(item);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  function getList() &#123;</div><div class="line">    return list;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面这个服务非常简单，调用 <code>addItem</code> 把数据放到列表里，然后调用 <code>getList</code> 获取整个列表。这真的很简单，甚至不需要去移除或者清空列表项，看到这个方法的简便之处了吧。</p>
<h3 id="在任何需要的地方注入服务"><a href="#在任何需要的地方注入服务" class="headerlink" title="在任何需要的地方注入服务"></a>在任何需要的地方注入服务</h3><p>既然我们已经创建好了我们的服务，我们就需要在任何需要访问或修改数据的地方去注入它了。</p>
<p>先从面板1的控制器开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// Inject sharedList</div><div class="line">controller: function(sharedList) &#123;</div><div class="line">  var vm = this;</div><div class="line">  vm.text = &quot;&quot;;</div><div class="line">  vm.addToList = function() &#123;</div><div class="line">    // Stuff the item into the shared list</div><div class="line">    sharedList.addItem(vm.text);</div><div class="line">    vm.text = &quot;&quot;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后是面板2的控制器，获取数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Inject sharedList</div><div class="line">controller: function(sharedList) &#123;</div><div class="line">  var vm = this;</div><div class="line">  // Read the data</div><div class="line">  vm.listItems = sharedList.getList();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从<a href="http://jsbin.com/wogumemufi/1/embed?js,output" target="_blank" rel="external">JSBin</a>里看看运行情况。</p>
<h3 id="但不需要观察器-watchers-吗？"><a href="#但不需要观察器-watchers-吗？" class="headerlink" title="但不需要观察器(watchers)吗？"></a>但不需要观察器(watchers)吗？</h3><p>当我写到这儿的时候，我非常确定面板2中的列表在我添加一些观察器前<strong>不会自动更新</strong> 。</p>
<p>但是接下来当我把代码放到 JSBin 里的时候…你瞧，它竟然可以更新！为什么呢？</p>
<ol>
<li><code>ng-repeat</code> 给循环的数组设置了观察器。</li>
<li>点击 “Add To List” 触发了一个消化周期 (digest cycle)，它就会重新检测 <code>ng-repeat</code> 的观察器。</li>
<li>因为 <code>sharedData.getList()</code> 返回了一个数组的引用，观察器就会看到 <code>p2.listItems</code> 已经发生了变化。<strong>这里是关键</strong>：如果 <code>getList</code> 返回一个不同于由 <code>addToList</code> 更改的数组，这就不会触发更新了。</li>
</ol>
<p>所以：这种通信方式可以在没有观察器的情况下完美运行。但如果你发现失败了的话，检查一下你是怎么传递数据的，或许你需要明确地创建一个观察器检测变化。</p>
<h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><ol>
<li>创建一个服务去存放你的数据，并给数据创建 <code>getter</code> 和 <code>setter</code> 的方法。</li>
<li>在任何需要这个数据的地方注入这个服务。</li>
<li>这几乎就是全部内容了（除非你需要观察器 - 这种情况下，你还是添加一个吧）。</li>
</ol>
<p>感谢阅读！</p>
]]></content:encoded>
      
      <comments>http://llp0574.github.io/2016/07/22/angular-controller-data-share/#disqus_thread</comments>
    </item>
    
    <item>
      <title>逐渐去掌握 React（作为一名 Angular 开发者）</title>
      <link>http://llp0574.github.io/2016/07/21/angular-to-react/</link>
      <guid>http://llp0574.github.io/2016/07/21/angular-to-react/</guid>
      <pubDate>Thu, 21 Jul 2016 14:02:26 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接 : &lt;a href=&quot;https://daveceddia.com/to-react-from-angular/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Getting to Grips with React (a
      
      </description>
      
      <content:encoded><![CDATA[<blockquote>
<p>原文链接 : <a href="https://daveceddia.com/to-react-from-angular/" target="_blank" rel="external">Getting to Grips with React (as an Angular developer)</a><br>原文作者 : <a href="https://daveceddia.com/" target="_blank" rel="external">DAVE CEDDIA</a><br>译者 : <a href="https://github.com/llp0574" target="_blank" rel="external">llp</a>（web前端领域）<br>译者注：翻译如有疏漏，欢迎指出！感谢！转载请保留此头部。</p>
</blockquote>
<p>你是一个对 React 感兴趣的 Angular 开发者吗？不用担心，这真的不会让你成为一个背叛者或其他什么，真的。</p>
<p>或许你早就已经开始玩 React 了：阅读了 Facebook 的官方教程，创建了一些组件…</p>
<p>也或许你正处于我几个月前处于的境地：对React完全没有经验，除了听说过它有多快，它有个虚拟 DOM 的概念，单向绑定，和一些像 <em>Flux</em> , <em>Redux</em> 和 <em>Reflux</em> 之类乱七八糟的东西。</p>
<p>在接下来一系列的文章里我将尝试帮助你将你辛苦习来的 “Angular” 主义知识应用到 React 当中。</p>
<p><img src="https://daveceddia.com/images/directives_eq_components@2x.png" alt="Angular to React"></p>
<p>在 Angular 里，你可能已经习惯去编写各种指令 <code>directive</code>。如果你是按照<a href="https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef" target="_blank" rel="external">流行的规范</a>去编码的话，相信你程序的各个部分都是由一个或多个指令构建而成，并到处都使用了隔离的作用域 <code>scope</code>（如果这听起来很熟悉但并不像你所做的话，或许你可以阅读一下<a href="https://daveceddia.com/convert-scope-to-controlleras/" target="_blank" rel="external">将scope转化为controllerAs</a>）。</p>
<p>React 有着相同的概念：编写组件 <code>component</code>。将你的程序按功能拆分成组件块，并尽可能让每个组件块保持独立和可复用性。事实上，这个想法并不是 React 或 Angular 独创的 - 它只是一种很棒的软件开发实践方式。尽可能写一些简短并具备可复用性的代码（函数，组件，指令，随便你怎么称呼它们）。</p>
<p>一个关键的差别在于 React 里 <strong>所有东西都是组件</strong> ，从根节点到下面所有。Angular 让你使用 <code>ng-controller</code> 去混合和匹配所有指令，并在之后特定地路由出各自的指令和模板… React 让这个事情变简单了一点。所有东西都是组件，页面，按钮甚至是路由，我们随后会讲到这些。</p>
<p>好了，所以说 React 的“组件”是类似于“指令”的。那么它的代码看起来是怎样的呢？</p>
<p>下面是一个展示歌曲名字的 Angular 指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">angular.module(&apos;demo&apos;, []).directive(&apos;songName&apos;, function() &#123;</div><div class="line">  return &#123;</div><div class="line">    scope: &#123;</div><div class="line">      song: &apos;=&apos;</div><div class="line">    &#125;,</div><div class="line">    restrict: &apos;E&apos;,</div><div class="line">    template: &apos;&lt;span class=&quot;song-name&quot;&gt;&#123;&#123; ctrl.song.name &#125;&#125;&lt;/span&gt;&apos;,</div><div class="line">    controller: function() &#123;&#125;,</div><div class="line">    controllerAs: &apos;ctrl&apos;,</div><div class="line">    bindToController: true</div><div class="line">  &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>接下来是用 React 写的相同功能的组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var SongName = React.createClass(&#123;</div><div class="line">  propTypes: &#123;</div><div class="line">    song: React.PropTypes.object.isRequired</div><div class="line">  &#125;,</div><div class="line">  render: function() &#123;</div><div class="line">    return &lt;span className=&apos;song-name&apos;&gt;&#123;this.props.song.name&#125;&lt;/span&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>你马上就可以发现一些相似之处：它们都期望得到一个 <code>song</code> 对象，并都似乎有各种各样的模板。</p>
<p>一些不同之处在于：React 相对 Angular 有着更少的代码。我敢说…更简洁了不是吗？React 里，期望的参数(<code>song</code>)有着某种类型验证，并且 HTML 没有引号！</p>
<p>事实上那个看上去没加引号的 HTML 并不是真正的 HTML。（等下就会讲到）</p>
<p><code>React.createClass</code> 和 <code>angular.directive</code> 类似 - 它创建了一个组件类。这个组件 <strong>必须</strong> 有一个 <code>render</code> 方法，<code>propTypes</code> 是一个可选对象，但最好把它写上。</p>
<p>还是要对得起 Angular ，它的1.5版本其实介绍了一个 <code>component</code> 方法来缩短指令的长度，所以上面的指令可以简写成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">angular.module(&apos;demo&apos;, []).component(&apos;songName&apos;, &#123;</div><div class="line">  bindings: &#123;</div><div class="line">    song: &apos;=&apos;</div><div class="line">  &#125;,</div><div class="line">  template: &apos;&lt;span class=&quot;song-name&quot;&gt;&#123;&#123; $ctrl.song.name &#125;&#125;&lt;/span&gt;&apos;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>更简单的写法。它甚至默认没有控制器！我推荐阅读一下<a href="https://toddmotto.com/exploring-the-angular-1-5-component-method/" target="_blank" rel="external">Todd Motto的关于组件方法的文章</a>并在你的代码里尝试一下。</p>
<p>但它还是没有 <code>propTypes</code> …</p>
<h3 id="propTypes"><a href="#propTypes" class="headerlink" title="propTypes"></a>propTypes</h3><p><img src="https://daveceddia.com/images/forgot_props@2x.png" alt=""></p>
<p><code>propTypes</code>是一个验证组件所需参数的方法。你可以把个别参数标记为“必需的”或“可选的”（默认它们都是可选的），把它想象成类型检测吧。</p>
<p>下面是真正很酷的部分：如果你指定了<code>propTypes</code>并说明一个参数是必需的（像上面那样），然后你忘记把它传进来，你就会在控制台得到一个提示信息。</p>
<p>比起 Angular 这真的太棒了！当你忘记给指令传参时你就再也不怕莫名其妙地报错了。</p>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>什么是 “prop” ?它实际上是 “property” 的简写（感谢 React 的开发者，让我们再也不用打出 <code>this.properties</code> 或者 <code>this.propertyTypes</code> 了）。</p>
<p>你可以把 <code>props</code> 看作是传给组件的属性。就像在指令里，你会在 HTML 元素里传递属性一样 - <code>props</code> 会在 JSX 元素里被当作属性传递。</p>
<h3 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h3><p>下面是 Angular 里指令的使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Notice how you have to mentally translate &apos;songName&apos; to &apos;song-name&apos;?</div><div class="line">&lt;song-name song=&quot;ctrl.song&quot;&gt;&lt;/song-name&gt;</div></pre></td></tr></table></figure>
<p>然后下面是 React 里组件的使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// Notice how you DON&apos;T need to mentally translate SongName to anything?</div><div class="line">&lt;SongName song=&#123;theSong&#125;/&gt;</div></pre></td></tr></table></figure>
<p>所有没有子元素的标签在 JSX 里都可以自终止。</p>
<p>但让我们先花几分钟来讲讲 JSX吧…</p>
<h3 id="JS里的HTML？！"><a href="#JS里的HTML？！" class="headerlink" title="JS里的HTML？！"></a>JS里的HTML？！</h3><p>在我对 React 了解不多的时候，我知道它是把 HTML 和 JS 混合起来的，然后我就想这样做真的很 <em>丑陋</em> 啊。我意思是，这对于最佳实践的思考来说已经很多年不会这么写了不是吗？从那段使用 jQuery 的黑暗日子开始，我们就已经知道在 JS 里写 HTML 元素是一件很取巧而且开发体验相当糟糕的事情，所以为什么 React 会再次犯同样的错误呢？</p>
<p>所以，这里有两件事情需要搞清楚：</p>
<ol>
<li><strong>那并不是字符串</strong>。<br>你注意到它是怎么做到不给 “HTML” 加引号的吗？那是因为它并不是 HTML。不加引号也并不是一种语法糖，React 是不会将那个东西转换成 HTML 的。</li>
<li><strong>那并不是HTML</strong>。<br>那是 <em>JSX</em> 。我知道它长得很像 HTML ，马上你可能会想：“JSX嘛 …只是对 HTML 做了一些细微的改变然后换了个名字而已”，好吧，你也可以那么说。我倒觉得它是给我们提供了一种用函数调用去创建 DOM 元素的语法糖。</li>
</ol>
<h3 id="JSX-编译成-Javascript"><a href="#JSX-编译成-Javascript" class="headerlink" title="JSX 编译成 Javascript"></a>JSX 编译成 Javascript</h3><p>创建 DOM 元素的函数调用？是的，看看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// This JSX...</div><div class="line">&lt;span className=&apos;song-name&apos;&gt;&#123;this.props.song.name&#125;&lt;/span&gt;</div><div class="line"></div><div class="line">// Compiles to this function call:</div><div class="line">React.createElement(&apos;span&apos;, &#123;className: &apos;song-name&apos;&#125;, this.props.song.name);</div><div class="line">// React.createElement(&apos;tagName&apos;, props, children);</div></pre></td></tr></table></figure>
<p>看起来还挺有道理的，不是吗？ HTML 创建嵌套的 DOM 节点，那我们就用嵌套的函数调用替代了嵌套的 DOM 节点…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// This is valid JSX:</div><div class="line">&lt;div&gt;</div><div class="line">  &lt;span className=&apos;greeting&apos;&gt;</div><div class="line">    &lt;strong&gt;Hello&lt;/strong&gt;</div><div class="line">    &lt;strong&gt;World&lt;/strong&gt;</div><div class="line">  &lt;/span&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">// ...which compiles to this call:</div><div class="line">React.createElement(&apos;div&apos;, null,</div><div class="line">  React.createElement(&apos;span&apos;, &#123;className: &apos;greeting&apos;&#125;,</div><div class="line">      React.createElement(&apos;strong&apos;, null, &apos;Hello&apos;),</div><div class="line">      React.createElement(&apos;strong&apos;, null, &apos;World&apos;)</div><div class="line">    ));</div></pre></td></tr></table></figure>
<p>实现上来说，这些 <code>React.createElement</code> 方法并没有创建真正的 DOM 节点，它们创建了虚拟的 DOM 节点。</p>
<h3 id="但…关注点的分离！"><a href="#但…关注点的分离！" class="headerlink" title="但…关注点的分离！"></a>但…关注点的分离！</h3><p>所以说我们并不是把 HTML 字符串写到 Javascript 里的！</p>
<p>但代码逻辑始终还是和表现层混合起来的！那可不能算对！这么多年的软件开发实践告诉我们这样做是很不好的。放心，现在只是还没做完呢，你并没有把视图和逻辑混合起来。</p>
<p>我认为这是一种类似“<a href="https://en.wikipedia.org/wiki/Cargo_cult_programming" target="_blank" rel="external">货物崇拜</a>”的东西，我们经常在没真正搞清楚为什么的情况下去赞同和执行。有很多很好的理由去说明为什么需要把逻辑和视图层给分离开，但当你回头再看会发现同样也有很多很好的理由去合并它们。</p>
<p>或许你已经写过一些带有控制器和分离的模板文件的 Angular 指令了是吧？</p>
<p>告诉我你有多么经常在看不到或者无法修改控制器的情况下去到模板文件里去修改一些东西？又有多么经常在没有接触到模板的情况下去修改控制器？</p>
<p>这些看上去算是你对关注点的分离吗？</p>
<p>我们喜欢把 JS 和 HTML 分离到不同的文件里去让它们“关注点分离”，可复用性我们来了！</p>
<p>但其实它们很少会那样工作。一个指令的控制器和模板通常会紧紧关联在一起，所以很自然地，它们就像是硬币的两面。把代码分离到不同的文件里并不会自动导致关注点分离。</p>
<p>如果你还没注意到的话，其实我是想尝试通过上面的说法告诉你模板和逻辑控制其实是可以共存在一个文件里的，而且这样做或许看起来更有道理一些。</p>
<h3 id="试试看"><a href="#试试看" class="headerlink" title="试试看"></a>试试看</h3><p>我敢打赌你还是充满疑惑。正常，我曾经也是的。</p>
<p>个人来说，我发现从长期以来信服的理论当中跳出来到一个看似完全相反的位置确实是一件相当困难的事情。我试过亲自去尝试那么做并证明给自己看这个新方法并不是那么糟糕。</p>
<p>希望你也可以去做同样的事情，只需要一点点时间。去尝试一下 <a href="https://facebook.github.io/react/docs/tutorial.html" target="_blank" rel="external">React 的官方教程</a>（不需要什么乱七八糟的工具 - 下载并运行他们的服务就可以开始写代码了），或者也可以试一下我的<a href="https://daveceddia.com/test-drive-react/" target="_blank" rel="external">三分钟输出 Hello World 教程</a>（不需要编译哦！）。</p>
<p>或许就可以像我做的那样，你会发现写 React 组件确实很有意思。又或者你会发现 React 并不是你想要的东西，但至少你尝试并验证过了。</p>
<p>如果你决定使用它了，那就回来这儿吧，我等你！</p>
]]></content:encoded>
      
      <comments>http://llp0574.github.io/2016/07/21/angular-to-react/#disqus_thread</comments>
    </item>
    
    <item>
      <title>iOS 开源图形库 Core Plot 使用教程</title>
      <link>http://llp0574.github.io/2016/07/20/core-plot/</link>
      <guid>http://llp0574.github.io/2016/07/20/core-plot/</guid>
      <pubDate>Wed, 20 Jul 2016 13:46:55 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接 : &lt;a href=&quot;https://www.raywenderlich.com/131985/core-plot-tutorial-getting-started&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Core
      
      </description>
      
      <content:encoded><![CDATA[<blockquote>
<p>原文链接 : <a href="https://www.raywenderlich.com/131985/core-plot-tutorial-getting-started" target="_blank" rel="external">Core Plot Tutorial: Getting Started</a><br>原文作者 : <a href="https://www.raywenderlich.com/u/cynicalme" target="_blank" rel="external">Attila Hegedüs</a><br>译文出自 : <a href="https://github.com/xitu/gold-miner" target="_blank" rel="external">掘金翻译计划</a><br>译者 : <a href="https://github.com/llp0574" target="_blank" rel="external">llp</a>（web前端领域）<br>校对者: <a href="https://github.com/yifili09" target="_blank" rel="external">yifili09</a>,<a href="https://github.com/cdpath" target="_blank" rel="external">cdpath</a><br>译者注：转载请保留此头部。</p>
</blockquote>
<p><img src="http://ac-Myg6wSTV.clouddn.com/868c57b7dfa6957573cd.png" alt="使用Core Plot绘制饼图，柱状图，散点图及更多！"></p>
<p><em>注意</em> ：本篇教程已被 Attila Hegedüs 更新，可适用于 iOS 9 和 Swift 2.2。原始教程出自教程组成员 Steve Baranski。</p>
<p>如果你曾经想在自己的 app 中引入图表或图形，那么你应该已经考虑过下面两种选项：</p>
<ol>
<li><em>自己写。</em> 通过使用 Core Graphics 或者 Quartz 这样的框架编写全部的绘制代码。然而，这显然要花费大量的功夫。</li>
<li><em>买一个！</em> 购买一个像 <a href="http://www.shinobicontrols.com" target="_blank" rel="external">ShinobiControls</a> 这样的商业型框架。这或许可以节省你的时间，但就要花钱啦。</li>
</ol>
<p>但是如果你不想花费时间和精力从零开始写(代码)，也不想花那么多钱，该怎么办呢？这时候第三个选项就派上用场了：使用开源库 <a href="https://github.com/core-plot/core-plot" target="_blank" rel="external">Core Plot</a>！</p>
<p>Core Plot 是一个2D绘制库，适用于 iOS，Mac OS X 和 tvOS。它使用了像 Quartz 和 Core Animation 这样的苹果应用框架，同时有着全面的测试覆盖，而且是遵照BSD这个比较宽松的许可证进行发布的。</p>
<p>在这个教程中，你将学习到如何使用 Core Plot 来创建饼图和柱状图，同时还会实现一些很酷的图表交互！</p>
<p>开始之前，你需要安装好 <em>Xcode 7.3</em> ，同时对 <em>Swift</em> ， <em>Interface Builder</em> 和 <em>storyboards</em> 有所了解。如果你对这些主题知之甚少，那么你应该在继续阅读本教程之前先学习一下我们其他的一些<a href="https://www.raywenderlich.com/?page_id=2519" target="_blank" rel="external">教程</a>。</p>
<p>本教程同时还使用了 CocoaPods 去安装一些第三方的依赖库。如果你从来没使用过 CocoaPods 的话，那你还应该阅读一下我们关于它的<a href="https://www.raywenderlich.com/97014/use-cocoapods-with-swift" target="_blank" rel="external">教程</a>。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>在本教程中，你将创建一个在一定时间间隔内显示货币汇率(情况)的 App。从<a href="https://cdn2.raywenderlich.com/wp-content/uploads/2016/05/SwiftRates_Starter-2.zip" target="_blank" rel="external">这里</a>下载本教程的入门项目，把它解压缩后打开 <em>SwiftRates.xcworkspace</em> 。</p>
<p>项目的关键类在 <em>App</em> 这个文件夹和它的子文件夹下，它们包括了：</p>
<ul>
<li><em>DataStore.swift</em><br>这是一个从 <a href="http://fixer.io/" target="_blank" rel="external">Fixer.io</a> 请求货币汇率数据的帮助类。</li>
<li><em>Rate.swift</em><br>这是一个模型，表示给定日期里的货币汇率。</li>
<li><em>Currency.swift</em><br>这是一个表示货币类型的模型。支持的货币类型定义在 <em>Resources/Currencies.plist</em> 里。</li>
<li><em>MenuViewController.swift</em><br>这是一个app启动后展示的第一个视图控制器。它让用户选择一个货币作为基准然后再选两个对照。</li>
<li><em>HostViewController.swift</em><br>这是一个容器视图控制器，基于它的分段选项选中状态去控制展示 <code>PieChartViewController</code> 或者 <code>BarGraphViewController</code> 的内容。它还会去检查从 <code>DataStore</code> 请求来的汇率数据，因为它们也将在这个视图控制器里展现。</li>
<li><em>PieChartViewController.swift</em><br>这个控制器将用饼图的形式展示一个给定日期里的汇率。当然你首先要实现它！</li>
<li><em>BarGraphViewController.swift</em><br>这个控制器将以柱状图的形式展示几天的汇率。当你掌握绘制饼图的方法后，这个图简直小菜一碟！（看到我做的事情了吗？拜托，这真的有点意思！）;]</li>
</ul>
<p>构建并运行看看这个教程入门项目实际展示。</p>
<p><img src="http://ac-Myg6wSTV.clouddn.com/f9346c33b479bfc2a302.png" alt=""></p>
<p>点选 <em>Get Rates</em> 导航去到 <code>HostViewController</code> 控制的视图然后可以切换分段选项。这个 app 确实还没有实现太多功能…;]</p>
<p>是时候用 Core Plot 开始真正的绘制了！</p>
<h3 id="安装-Core-Plot"><a href="#安装-Core-Plot" class="headerlink" title="安装 Core Plot"></a>安装 Core Plot</h3><p>首先你需要安装 Core Plot，最简单的方式是通过 <a href="https://cocoapods.org/" target="_blank" rel="external">CocoaPods</a> 安装。</p>
<p>把下面这行代码添加进你的 <em>Podfile</em> 文件， <code>pod &#39;SwiftDate&#39;</code> 这行的后面：</p>
<pre><code>pod &apos;CorePlot&apos;, &apos;~&gt; 2.1&apos;
</code></pre><p>打开 <em>Terminal</em> （终端），<code>cd</code> 进入你的项目根目录，然后运行 <code>pod install</code>。</p>
<p>安装完成后，构建项目。</p>
<p>没报错吧？很好，现在你可以随便使用 Core Plot 啦，感谢 CocoaPods。:]</p>
<p>如果你遇到了任何报错，可以尝试通过 <code>sudo gem install cocoapods</code> 更新一下 CocoaPods 然后再次运行 <code>pod install</code>。</p>
<h2 id="创建饼图"><a href="#创建饼图" class="headerlink" title="创建饼图"></a>创建饼图</h2><p>打开 <em>PieChartViewController.swift</em> 并添加下面这行引入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import CorePlot</div></pre></td></tr></table></figure></p>
<p>接着，添加下面这个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@IBOutlet weak var hostView: CPTGraphHostingView!</div></pre></td></tr></table></figure>
<p><code>CPTGraphHostingView</code> 负责“托管”一个图表或图形。你可以把它想象成一个“图形容器”。</p>
<p>然后，把下面这个类扩展添加到文件结尾的花括号之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">extension PieChartViewController: CPTPieChartDataSource, CPTPieChartDelegate &#123;</div><div class="line"></div><div class="line">  func numberOfRecordsForPlot(plot: CPTPlot) -&gt; UInt &#123;</div><div class="line">    return 0</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  func numberForPlot(plot: CPTPlot, field fieldEnum: UInt, recordIndex idx: UInt) -&gt; AnyObject? &#123;</div><div class="line">    return 0</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  func dataLabelForPlot(plot: CPTPlot, recordIndex idx: UInt) -&gt; CPTLayer? &#123;</div><div class="line">    return nil</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  func sliceFillForPieChart(pieChart: CPTPieChart, recordIndex idx: UInt) -&gt; CPTFill? &#123;</div><div class="line">    return nil</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  func legendTitleForPieChart(pieChart: CPTPieChart, recordIndex idx: UInt) -&gt; String? &#123;</div><div class="line">    return nil</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你将通过 <code>CPTPieChartDataSource</code> 为一个 Core Plot 图表提供数据，同时你会通过 <code>CPTPieChartDelegate</code> 得到用户交互的所有事件。随着教程递进，你将填满这些方法。</p>
<h3 id="建立图表托管视图"><a href="#建立图表托管视图" class="headerlink" title="建立图表托管视图"></a>建立图表托管视图</h3><p>继续往下，打开 <em>Main.storyboard</em> 然后选择 <code>PieChartViewController</code> 窗口。</p>
<p>在这个视图上拖出一个新的 <code>UIView</code>，然后把它的类更改成 <code>CPTGraphHostingView</code>，并将它连接到 <code>hostView</code>。</p>
<p>对这个视图的每个方向添加约束让撑满父视图，并确认没有设置外边距的约束：</p>
<p><img src="https://cdn2.raywenderlich.com/wp-content/uploads/2016/04/swiftrates-05.png" alt=""></p>
<p>设置一个你喜欢的背景色。我使用了透明度为92%的灰度颜色。</p>
<p>现在回到 <em>PieChartViewController.swift</em> ，在 <code>viewDidLoad()</code> 后面添加下面的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">override func viewDidLayoutSubviews() &#123;</div><div class="line">  super.viewDidLayoutSubviews()</div><div class="line">  initPlot()</div><div class="line">&#125;</div><div class="line"></div><div class="line">func initPlot() &#123;</div><div class="line">  configureHostView()</div><div class="line">  configureGraph()</div><div class="line">  configureChart()</div><div class="line">  configureLegend()</div><div class="line">&#125;</div><div class="line"></div><div class="line">func configureHostView() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func configureGraph() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func configureChart() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func configureLegend() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样子就正好在子视图渲染好后设置了绘制策略。这里是你最早为视图设置框架大小的地方，接下来你将需要配置绘制策略。</p>
<p><code>initPlot()</code> 里的每个方法都代表了一个设置绘制策略的阶段。这样子可以让代码保持其可维护性。</p>
<p>把下面这行添加进 <code>configureHostView()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hostView.allowPinchScaling = false</div></pre></td></tr></table></figure>
<p>这行代码将对饼图禁用手势捏合缩放，它决定了托管视图对捏合手势是否会有反应。</p>
<p>接下来你需要添加一个图表到<code>hostView</code>。添加下面的代码到 <code>configureGraph()</code> 里吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 1 - Create and configure the graph</div><div class="line">let graph = CPTXYGraph(frame: hostView.bounds)</div><div class="line">hostView.hostedGraph = graph</div><div class="line">graph.paddingLeft = 0.0</div><div class="line">graph.paddingTop = 0.0</div><div class="line">graph.paddingRight = 0.0</div><div class="line">graph.paddingBottom = 0.0</div><div class="line">graph.axisSet = nil</div><div class="line"></div><div class="line">// 2 - Create text style</div><div class="line">let textStyle: CPTMutableTextStyle = CPTMutableTextStyle()</div><div class="line">textStyle.color = CPTColor.blackColor()</div><div class="line">textStyle.fontName = &quot;HelveticaNeue-Bold&quot;</div><div class="line">textStyle.fontSize = 16.0</div><div class="line">textStyle.textAlignment = .Center</div><div class="line"></div><div class="line">// 3 - Set graph title and text style</div><div class="line">graph.title = &quot;\(base.name) exchange rates\n\(rate.date)&quot;</div><div class="line">graph.titleTextStyle = textStyle</div><div class="line">graph.titlePlotAreaFrameAnchor = CPTRectAnchor.Top</div></pre></td></tr></table></figure>
<p>下面对每个部分的代码进行分解：</p>
<ol>
<li><p>首先你创建了一个 <code>CPTXYGraph</code> 的实例并指定它作为 <code>hostView</code> 的 <code>hostedGraph</code>。这就将图表和托管视图联系起来了。</p>
<p>这个 <code>CPTGraph</code> 包括了你所看到的标准图表或图形的全部东西：边，标题，绘制相关数据，轴和图例。</p>
<p>默认情况下，<code>CPTXYGraph</code> 每个方向都有一个<code>20</code>的内边距。从我们这个项目来看这样并不好，所以你可以显式地将每个方向的内边距设置为<code>0</code>。</p>
</li>
<li><p>接下来就是通过创建和配置一个 <code>CPTMutableTextStyle</code> 实例来设置该图标标题的文本样式。</p>
</li>
<li>最后，就是给你刚刚创建的图表实例设置标题和其样式。同样你还需要指定标题锚点为该视图的上边界。</li>
</ol>
<p>构建并运行app，你应该就可以看到这个图表的标题展示在屏幕上了：</p>
<p><img src="http://ac-Myg6wSTV.clouddn.com/fd0411a63ef0affb512a.png" alt="Core Plot Tutorial"></p>
<h3 id="绘制饼图"><a href="#绘制饼图" class="headerlink" title="绘制饼图"></a>绘制饼图</h3><p>标题看起来不错，但你知道接下来什么会更棒吗？确确实实地看到饼图！</p>
<p>将下面的代码添加进 <code>configureChart()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">    // 1 - Get a reference to the graph</div><div class="line">    let graph = hostView.hostedGraph!</div><div class="line"></div><div class="line">    // 2 - Create the chart</div><div class="line">    let pieChart = CPTPieChart()</div><div class="line">    pieChart.delegate = self</div><div class="line">    pieChart.dataSource = self</div><div class="line">    pieChart.pieRadius = (min(hostView.bounds.size.width, hostView.bounds.size.height) * 0.7) / 2</div><div class="line">    pieChart.identifier = graph.title</div><div class="line">    pieChart.startAngle = CGFloat(M_PI_4)</div><div class="line">    pieChart.sliceDirection = .Clockwise</div><div class="line">    pieChart.labelOffset = -0.6 * pieChart.pieRadius</div><div class="line"></div><div class="line">    // 3 - Configure border style</div><div class="line">    let borderStyle = CPTMutableLineStyle()</div><div class="line">    borderStyle.lineColor = CPTColor.whiteColor()</div><div class="line">    borderStyle.lineWidth = 2.0</div><div class="line">    pieChart.borderLineStyle = borderStyle</div><div class="line"></div><div class="line">    // 4 - Configure text style</div><div class="line">    let textStyle = CPTMutableTextStyle()</div><div class="line">    textStyle.color = CPTColor.whiteColor()</div><div class="line">    textStyle.textAlignment = .Center</div><div class="line">    pieChart.labelTextStyle = textStyle</div><div class="line"></div><div class="line">    // 3 - Add chart to graph</div><div class="line">    graph.addPlot(pieChart)</div><div class="line">```</div></pre></td></tr></table></figure>
<p>下面看看这段代码做了什么：</p>
<ol>
<li>首先获取了刚刚创建的图表的引用。</li>
<li>然后实例化一个 <code>CPTPieChart</code>，将它的代理和数据源设置成这个视图控制器本身，并配置它的一些外观属性。</li>
<li>接着配置这个图表的边框样式。</li>
<li>配置它的文本样式。</li>
<li>最后，将这个饼图添加进刚刚引用的图表里。</li>
</ol>
<p>如果现在重新构建并运行 app，你将看不到任何变化…因为你还需要实现这个饼图的代理和数据源。</p>
<p>首先，用下面这段替代了现在的 <code>numberOfRecordsForPlot(_:)</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func numberOfRecordsForPlot(plot: CPTPlot) -&gt; UInt &#123;</div><div class="line">  return UInt(symbols.count) ?? 0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法决定了有多少块(部分)显示在饼状图上，它将为每一个标记显示一块(部分)。</p>
<p>接下来，用下面这段替换掉 <code>numberForPlot(_:field:recordIndex:)</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func numberForPlot(plot: CPTPlot, field fieldEnum: UInt, recordIndex idx: UInt) -&gt; AnyObject? &#123;</div><div class="line">  let symbol = symbols[Int(idx)]</div><div class="line">  let currencyRate = rate.rates[symbol.name]!.floatValue</div><div class="line">  return 1.0 / currencyRate</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>饼图会使用这个方法得到索引为 <code>recordIndex</code> 的货币符号的“总”值。</p>
<p>你应该注意到这个值并 <em>不是</em> 一个百分比值。取而代之的是，这个方法计算出了相对基准货币的货币汇率：返回的这个 <code>1.0 / currencyRate</code> 的值是”一个单位的基准货币是多少价值的另外的对照货币”的汇率。</p>
<p><code>CPTPieChart</code> 将查看计算每个分块的百分比值，这个值最终决定了这个分块占多大。</p>
<p>下面，用下面这行替代掉 <code>dataLabelForPlot(_:recordIndex:)</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func dataLabelForPlot(plot: CPTPlot, recordIndex idx: UInt) -&gt; CPTLayer? &#123;</div><div class="line">  let value = rate.rates[symbols[Int(idx)].name]!.floatValue</div><div class="line">  let layer = CPTTextLayer(text: String(format: &quot;\(symbols[Int(idx)].name)\n%.2f&quot;, value))</div><div class="line">  layer.textStyle = plot.labelTextStyle</div><div class="line">  return layer</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法返回了饼图分片的标签。期望的返回类型 <code>CPTLayer</code> 和 <code>CALayer</code> 有点相似，但是 CPTLayer 更加抽象，在 Mac OS X 和 iOS 上都能用，还提供了额外的绘图细节供 Core Plot 使用。</p>
<p>这里，创建并返回一个 <code>CPTLayer</code> 的子类 <code>CPTTextLayer</code> 去展示文本。</p>
<p>最后，将下面这段代码替换掉 <code>sliceFillForPieChart(_:, recordIndex:)</code> 去添加分片的颜色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func sliceFillForPieChart(pieChart: CPTPieChart, recordIndex idx: UInt) -&gt; CPTFill? &#123;</div><div class="line">  switch idx &#123;</div><div class="line">  case 0:   return CPTFill(color: CPTColor(componentRed:0.92, green:0.28, blue:0.25, alpha:1.00))</div><div class="line">  case 1:   return CPTFill(color: CPTColor(componentRed:0.06, green:0.80, blue:0.48, alpha:1.00))</div><div class="line">  case 2:   return CPTFill(color: CPTColor(componentRed:0.22, green:0.33, blue:0.49, alpha:1.00))</div><div class="line">  default:  return nil</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构建并运行，你就将看到一个漂亮的饼图了：</p>
<p><img src="http://ac-Myg6wSTV.clouddn.com/17097b407bd6dbdcc299.png" alt="Core Plot Tutorial"></p>
<h3 id="等一下…图例呢！"><a href="#等一下…图例呢！" class="headerlink" title="等一下…图例呢！"></a>等一下…图例呢！</h3><p>这个图表看上去相当不错，但是添加一个图例应该会让它更棒。接下来你将学习怎么添加一个图例到这个图表里。</p>
<p>首先，用下面这段替换掉 <code>configureLegend()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">func configureLegend() &#123;</div><div class="line">  // 1 - Get graph instance</div><div class="line">  guard let graph = hostView.hostedGraph else &#123; return &#125;</div><div class="line"></div><div class="line">  // 2 - Create legend</div><div class="line">  let theLegend = CPTLegend(graph: graph)</div><div class="line"></div><div class="line">  // 3 - Configure legend</div><div class="line">  theLegend.numberOfColumns = 1</div><div class="line">  theLegend.fill = CPTFill(color: CPTColor.whiteColor())</div><div class="line">  let textStyle = CPTMutableTextStyle()</div><div class="line">  textStyle.fontSize = 18</div><div class="line">  theLegend.textStyle = textStyle</div><div class="line"></div><div class="line">  // 4 - Add legend to graph</div><div class="line">  graph.legend = theLegend</div><div class="line">  if view.bounds.width &gt; view.bounds.height &#123;</div><div class="line">    graph.legendAnchor = .Right</div><div class="line">    graph.legendDisplacement = CGPoint(x: -20, y: 0.0)</div><div class="line"></div><div class="line">  &#125; else &#123;</div><div class="line">    graph.legendAnchor = .BottomRight</div><div class="line">    graph.legendDisplacement = CGPoint(x: -8.0, y: 8.0)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样你也需要为每个分片提供图例的数据。</p>
<p>要提供数据，就用下面这段替换掉 <code>legendTitleForPieChart(_:recordIndex:)</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func legendTitleForPieChart(pieChart: CPTPieChart, recordIndex idx: UInt) -&gt; String? &#123;</div><div class="line">  return symbols[Int(idx)].name</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构建并运行，你就会得到一个“带图例的”图表啦。</p>
<p><img src="http://ac-Myg6wSTV.clouddn.com/98244c1f592db447f90a.png" alt="Core Plot Tutorial"></p>
<h2 id="创建柱状图"><a href="#创建柱状图" class="headerlink" title="创建柱状图"></a>创建柱状图</h2><p>看样子你已经是绘制饼图的专家啦，但是时候去搞一个柱状图了！</p>
<p>打开 <code>BarGraphViewController</code> 并添加下面这行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import CorePlot</div></pre></td></tr></table></figure></p>
<p>接着，再添加下面这行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@IBOutlet var hostView: CPTGraphHostingView!</div></pre></td></tr></table></figure>
<p>其实就和饼图一样，托管视图将承载这个柱状图的展示。</p>
<p>下一步，添加下面这些属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var plot1: CPTBarPlot!</div><div class="line">var plot2: CPTBarPlot!</div><div class="line">var plot3: CPTBarPlot!</div></pre></td></tr></table></figure>
<p>这里声明了三个 <code>CPTBarPlot</code> 类型的属性，它们就相当于展示在图表中的每种货币。</p>
<p>注意到同样也有三个 <code>IBOutlet</code> 标签和三个 <code>IBAction</code> 方法已经被定义了，你都可以在 storyboard 上看到它们。</p>
<p>最后，把下面这个类扩展添加到文件末尾：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">extension BarGraphViewController: CPTBarPlotDataSource, CPTBarPlotDelegate &#123;</div><div class="line"></div><div class="line">  func numberOfRecordsForPlot(plot: CPTPlot) -&gt; UInt &#123;</div><div class="line">    return 0</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  func numberForPlot(plot: CPTPlot, field fieldEnum: UInt, recordIndex idx: UInt) -&gt; AnyObject? &#123;</div><div class="line">    return 0</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  func barPlot(plot: CPTBarPlot, barWasSelectedAtRecordIndex idx: UInt, withEvent event: UIEvent) &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这和创建饼图的过程太像了：通过 <code>CPTBarPlotDataSource</code> 为柱状图提供数据，通过 <code>CPTBarPlotDelegate</code> 捕捉用户交互事件。你只需要复制粘贴就好了。</p>
<h3 id="再次配置图表托管视图"><a href="#再次配置图表托管视图" class="headerlink" title="再次配置图表托管视图"></a>再次配置图表托管视图</h3><p>就像刚刚创建饼图时候一样，再次需要通过界面生成器把托管视图添加进去。</p>
<p>回到 <em>Main.storyboard</em> 并选择 <code>BarGraphViewController</code> 窗口。</p>
<p>在视图上拖拽出一个新的 <code>UIView</code>，将它的类更改为 <code>CPTGraphHostingView</code> 并将其输出连接到控制器里的 <code>hostView</code>。</p>
<p>通过 <em>Utilities\Size Inspector</em> （那个 <em>刻度尺</em> 选项卡）将它的框架更新到下面那样：</p>
<p><em>X = 0, Y = 53, Width = 600, Height = 547</em></p>
<p><img src="http://ww1.sinaimg.cn/large/a490147fjw1f5tbltfjfpj20dc07oaam.jpg" alt=""></p>
<p>添加它和所有相邻元素的约束，确认没有设置 <em>外边距约束</em> 。</p>
<p><img src="https://cdn5.raywenderlich.com/wp-content/uploads/2016/05/BarGraph_HostView_Constraints.png" alt=""></p>
<p>最后，设置一个你喜欢的背景颜色。我再次用了92%透明度的灰度颜色。</p>
<h3 id="绘制柱状图"><a href="#绘制柱状图" class="headerlink" title="绘制柱状图"></a>绘制柱状图</h3><p>既然 UI 已经通过上面的学习全部弄好了，是时候去绘制一个柱状图了。</p>
<p>首先，回到 <code>BarGraphViewController</code>，你需要一对常量属性。把下面这段添加到其他属性之前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let BarWidth = 0.25</div><div class="line">let BarInitialX = 0.25</div></pre></td></tr></table></figure>
<p>你还需要一个帮助函数去计算最高的率值。把下面这段添加到 <code>updateLabels()</code>之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func highestRateValue() -&gt; Double &#123;</div><div class="line">  var maxRate = DBL_MIN</div><div class="line">  for rate in rates &#123;</div><div class="line">    maxRate = max(maxRate, rate.maxRate().doubleValue)</div><div class="line">  &#125;</div><div class="line">  return maxRate</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着，把下面的方法添加到 <code>highestRateValue()</code> 之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">override func viewDidLayoutSubviews() &#123;</div><div class="line">  super.viewDidLayoutSubviews()</div><div class="line">  initPlot()</div><div class="line">&#125;</div><div class="line"></div><div class="line">func initPlot() &#123;</div><div class="line">  configureHostView()</div><div class="line">  configureGraph()</div><div class="line">  configureChart()</div><div class="line">  configureAxes()</div><div class="line">&#125;</div><div class="line"></div><div class="line">func configureHostView() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func configureGraph() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func configureChart() &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func configureAxes() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>是不是看上去很眼熟？是的，这些和之前的结构完全一样。</p>
<p>下面这行添加到 <code>configureHostView()</code> 里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hostView.allowPinchScaling = false</div></pre></td></tr></table></figure>
<p>因为你不需要捏合缩放，所以你应该再次把它禁用。</p>
<p>接着，把下面那么多行代码添加到 <code>configureGraph()</code> 里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// 1 - Create the graph</div><div class="line">let graph = CPTXYGraph(frame: hostView.bounds)</div><div class="line">graph.plotAreaFrame?.masksToBorder = false</div><div class="line">hostView.hostedGraph = graph</div><div class="line"></div><div class="line">// 2 - Configure the graph</div><div class="line">graph.applyTheme(CPTTheme(named: kCPTPlainWhiteTheme))</div><div class="line">graph.fill = CPTFill(color: CPTColor.clearColor())</div><div class="line">graph.paddingBottom = 30.0</div><div class="line">graph.paddingLeft = 30.0</div><div class="line">graph.paddingTop = 0.0</div><div class="line">graph.paddingRight = 0.0</div><div class="line"></div><div class="line">// 3 - Set up styles</div><div class="line">let titleStyle = CPTMutableTextStyle()</div><div class="line">titleStyle.color = CPTColor.blackColor()</div><div class="line">titleStyle.fontName = &quot;HelveticaNeue-Bold&quot;</div><div class="line">titleStyle.fontSize = 16.0</div><div class="line">titleStyle.textAlignment = .Center</div><div class="line">graph.titleTextStyle = titleStyle</div><div class="line"></div><div class="line">let title = &quot;\(base.name) exchange rates\n\(rates.first!.date) - \(rates.last!.date)&quot;</div><div class="line">graph.title = title</div><div class="line">graph.titlePlotAreaFrameAnchor = .Top</div><div class="line">graph.titleDisplacement = CGPointMake(0.0, -16.0)</div><div class="line"></div><div class="line">// 4 - Set up plot space</div><div class="line">let xMin = 0.0</div><div class="line">let xMax = Double(rates.count)</div><div class="line">let yMin = 0.0</div><div class="line">let yMax = 1.4 * highestRateValue()</div><div class="line">guard let plotSpace = graph.defaultPlotSpace as? CPTXYPlotSpace else &#123; return &#125;</div><div class="line">plotSpace.xRange = CPTPlotRange(locationDecimal: CPTDecimalFromDouble(xMin), lengthDecimal: CPTDecimalFromDouble(xMax - xMin))</div><div class="line">plotSpace.yRange = CPTPlotRange(locationDecimal: CPTDecimalFromDouble(yMin), lengthDecimal: CPTDecimalFromDouble(yMax - yMin))</div></pre></td></tr></table></figure>
<p>下面是这段代码逻辑的拆解：</p>
<ol>
<li>首先，实例化一个 <code>CPTXYGraph</code>，实际上就是一个柱状图，并将它关联到 <code>hostView</code>。</li>
<li>然后声明一个 <em>简约的白色</em> 默认主题并为了展示 XY 轴去设置左侧和下方的内边距。</li>
<li>接着设置文本样式，图表标题以及标题位置。</li>
<li>最后，配置 <code>CPTXYPlotSpace</code>，它负责将设备的坐标系映射到图表的坐标系。针对这个图表，你正在绘制三个使用了相同坐标系的汇率。然而，也有可能每个条形图的坐标系都是 <em>分离</em> 的。你还要在坐标系中假定一个最大最小值汇率范围。在后面的教程中，你将学习到怎么样在不提前设定范围的情况下自动调节空间大小。</li>
</ol>
<p>既然已经创建好图表了，那是时候增加一些绘制方法进去了！把下面的代码添加到 <code>configureChart()</code>里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 1 - Set up the three plots</div><div class="line">plot1 = CPTBarPlot()</div><div class="line">plot1.fill = CPTFill(color: CPTColor(componentRed:0.92, green:0.28, blue:0.25, alpha:1.00))</div><div class="line">plot2 = CPTBarPlot()</div><div class="line">plot2.fill = CPTFill(color: CPTColor(componentRed:0.06, green:0.80, blue:0.48, alpha:1.00))</div><div class="line">plot3 = CPTBarPlot()</div><div class="line">plot3.fill = CPTFill(color: CPTColor(componentRed:0.22, green:0.33, blue:0.49, alpha:1.00))</div><div class="line"></div><div class="line">// 2 - Set up line style</div><div class="line">let barLineStyle = CPTMutableLineStyle()</div><div class="line">barLineStyle.lineColor = CPTColor.lightGrayColor()</div><div class="line">barLineStyle.lineWidth = 0.5</div><div class="line"></div><div class="line">// 3 - Add plots to graph</div><div class="line">guard let graph = hostView.hostedGraph else &#123; return &#125;</div><div class="line">var barX = BarInitialX</div><div class="line">let plots = [plot1, plot2, plot3]</div><div class="line">for plot: CPTBarPlot in plots &#123;</div><div class="line">  plot.dataSource = self</div><div class="line">  plot.delegate = self</div><div class="line">  plot.barWidth = BarWidth</div><div class="line">  plot.barOffset = barX</div><div class="line">  plot.lineStyle = barLineStyle</div><div class="line">  graph.addPlot(plot, toPlotSpace: graph.defaultPlotSpace)</div><div class="line">  barX += BarWidth</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着来看看上面的代码干了什么：</p>
<ol>
<li>实例化每个条形图并设置它们的填充色。</li>
<li>实例化一个代表每个条形图的外部边框的 <code>CPTMutableLineStyle</code> 实例。</li>
<li>给每个条形图提供“共同配置”。该配置包括设置数据源和代理，宽度和每个条形图在坐标系中的相对位置（左右）以及线条样式，最后，添加这个坐标系到图表当中。</li>
</ol>
<p>虽然还不可以看到柱状图展示出来，但通过构建 app 可以去验证目前为止是否所有代码都可以正确编译通过。</p>
<p>为了确切看到柱状图展示数据出来，需要去实现提供图表所需数据的代理方法。</p>
<p>用下面这行替换掉 <code>numberOfRecordsForPlot(:_)</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return UInt(rates.count ?? 0)</div></pre></td></tr></table></figure>
<p>该方法返回了应该展示的记录的总数。</p>
<p>下面这段替换掉 <code>numberForPlot(_:field:recordIndex:)</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">if fieldEnum == UInt(CPTBarPlotField.BarTip.rawValue) &#123;</div><div class="line">  if plot == plot1 &#123;</div><div class="line">    return 1.0</div><div class="line">  &#125;</div><div class="line">  if plot == plot2 &#123;</div><div class="line">    return rates[Int(idx)].rates[symbols[0].name]!.floatValue</div><div class="line">  &#125;</div><div class="line">  if plot == plot3 &#123;</div><div class="line">    return rates[Int(idx)].rates[symbols[1].name]!.floatValue</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">return idx</div></pre></td></tr></table></figure>
<p><code>CPTBarPlotField.BarTip</code> 的值表明了柱状图的相对大小。在你需要取回数据的时候可以使用保留属性计算出汇率，<code>recordIndex</code> 对应了利息率的位置。</p>
<p>构建并运行，你应该可以看到和下面这张图一样的情况：</p>
<p><img src="http://ac-Myg6wSTV.clouddn.com/4b5878afc9ec6c9b4427.png" alt="Core Plot Tutorial"></p>
<p>已经快完成了！但请注意还没有任何东西指明每个坐标轴是代表什么意思。</p>
<p>要解决这个问题，把下面这段添加进 <code>configureAxes()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">// 1 - Configure styles</div><div class="line">let axisLineStyle = CPTMutableLineStyle()</div><div class="line">axisLineStyle.lineWidth = 2.0</div><div class="line">axisLineStyle.lineColor = CPTColor.blackColor()</div><div class="line"></div><div class="line">// 2 - Get the graph&apos;s axis set</div><div class="line">guard let axisSet = hostView.hostedGraph?.axisSet as? CPTXYAxisSet else &#123; return &#125;</div><div class="line"></div><div class="line">// 3 - Configure the x-axis</div><div class="line">if let xAxis = axisSet.xAxis &#123;</div><div class="line">  xAxis.labelingPolicy = .None</div><div class="line">  xAxis.majorIntervalLength = 1</div><div class="line">  xAxis.axisLineStyle = axisLineStyle</div><div class="line">  var majorTickLocations = Set&lt;nsnumber&gt;()</div><div class="line">  var axisLabels = Set&lt;cptaxislabel&gt;()</div><div class="line">  for (idx, rate) in rates.enumerate() &#123;</div><div class="line">    majorTickLocations.insert(idx)</div><div class="line">    let label = CPTAxisLabel(text: &quot;\(rate.date)&quot;, textStyle: CPTTextStyle())</div><div class="line">    label.tickLocation = idx</div><div class="line">    label.offset = 5.0</div><div class="line">    label.alignment = .Left</div><div class="line">    axisLabels.insert(label)</div><div class="line">  &#125;</div><div class="line">  xAxis.majorTickLocations = majorTickLocations</div><div class="line">  xAxis.axisLabels = axisLabels</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 4 - Configure the y-axis</div><div class="line">if let yAxis = axisSet.yAxis &#123;</div><div class="line">  yAxis.labelingPolicy = .FixedInterval</div><div class="line">  yAxis.labelOffset = -10.0</div><div class="line">  yAxis.minorTicksPerInterval = 3</div><div class="line">  yAxis.majorTickLength = 30</div><div class="line">  let majorTickLineStyle = CPTMutableLineStyle()</div><div class="line">  majorTickLineStyle.lineColor = CPTColor.blackColor().colorWithAlphaComponent(0.1)</div><div class="line">  yAxis.majorTickLineStyle = majorTickLineStyle</div><div class="line">  yAxis.minorTickLength = 20</div><div class="line">  let minorTickLineStyle = CPTMutableLineStyle()</div><div class="line">  minorTickLineStyle.lineColor = CPTColor.blackColor().colorWithAlphaComponent(0.05)</div><div class="line">  yAxis.minorTickLineStyle = minorTickLineStyle</div><div class="line">  yAxis.axisLineStyle = axisLineStyle</div><div class="line">&#125;&lt;/cptaxislabel&gt;&lt;/nsnumber&gt;</div></pre></td></tr></table></figure>
<p>简单地说，上面的代码首先为轴线和标题定义了样式，然后，为图表添加坐标轴的设置并配置好 x 轴和 y 轴的一些属性。</p>
<p>构建并运行就可以看到这些改动的结果了。</p>
<p><img src="https://cdn2.raywenderlich.com/wp-content/uploads/2016/04/swiftrates-09.png" alt="Core Plot Tutorial"></p>
<h3 id="功能化坐标轴"><a href="#功能化坐标轴" class="headerlink" title="功能化坐标轴"></a>功能化坐标轴</h3><p>更棒了对吧？唯一的缺陷在于这个坐标轴太简单了，没办法从这儿得到一个准确的汇率展示。</p>
<p>你可以修复这个问题以便当用户点按在一个单独的柱状图时，这个 app 可以展示这个图表示的汇率。为了实现它，需要增加一个新的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var priceAnnotation: CPTPlotSpaceAnnotation?</div></pre></td></tr></table></figure>
<p>然后把下面的代码添加到 <code>barPlot(_:barWasSelectedAtRecordIndex:)</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">// 1 - Is the plot hidden?</div><div class="line">if plot.hidden == true &#123;</div><div class="line">  return</div><div class="line">&#125;</div><div class="line">// 2 - Create style, if necessary</div><div class="line">let style = CPTMutableTextStyle()</div><div class="line">style.fontSize = 12.0</div><div class="line">style.fontName = &quot;HelveticaNeue-Bold&quot;</div><div class="line"></div><div class="line">// 3 - Create annotation</div><div class="line">guard let price = numberForPlot(plot,</div><div class="line">                                field: UInt(CPTBarPlotField.BarTip.rawValue),</div><div class="line">                                recordIndex: idx) as? CGFloat else &#123; return &#125;</div><div class="line"></div><div class="line">priceAnnotation?.annotationHostLayer?.removeAnnotation(priceAnnotation)</div><div class="line">priceAnnotation = CPTPlotSpaceAnnotation(plotSpace: plot.plotSpace!, anchorPlotPoint: [0,0])</div><div class="line"></div><div class="line">// 4 - Create number formatter</div><div class="line">let formatter = NSNumberFormatter()</div><div class="line">formatter.maximumFractionDigits = 2</div><div class="line">// 5 - Create text layer for annotation</div><div class="line">let priceValue = formatter.stringFromNumber(price)!</div><div class="line">let textLayer = CPTTextLayer(text: priceValue, style: style)</div><div class="line"></div><div class="line">priceAnnotation!.contentLayer = textLayer</div><div class="line">// 6 - Get plot index</div><div class="line">var plotIndex: Int = 0</div><div class="line">if plot == plot1 &#123;</div><div class="line">  plotIndex = 0</div><div class="line">&#125;</div><div class="line">else if plot == plot2 &#123;</div><div class="line">  plotIndex = 1</div><div class="line">&#125;</div><div class="line">else if plot == plot3 &#123;</div><div class="line">  plotIndex = 2</div><div class="line">&#125;</div><div class="line">// 7 - Get the anchor point for annotation</div><div class="line">let x = CGFloat(idx) + CGFloat(BarInitialX) + (CGFloat(plotIndex) * CGFloat(BarWidth))</div><div class="line">let y = CGFloat(price) + 0.05</div><div class="line">priceAnnotation!.anchorPlotPoint = [x, y]</div><div class="line">// 8 - Add the annotation</div><div class="line">guard let plotArea = plot.graph?.plotAreaFrame?.plotArea else &#123; return &#125;</div><div class="line">plotArea.addAnnotation(priceAnnotation)</div></pre></td></tr></table></figure>
<p>这里需要一些解释：</p>
<ol>
<li>不要给一个隐藏的柱状图展示注解，而当图没有设置隐藏属性的时候，在把切换开关整合到图表之后，你就将实现它了。</li>
<li>这里还要为你的注解创建一个文本样式。</li>
<li>得到指定柱状图的汇率，然后如果它不存在一个注解对象，就创建一个。</li>
<li>如果没有数值格式化的方法还需要创建一个，因为在汇率展示的时候需要先格式化它。</li>
<li>创建一个使用这个格式化汇率的文本层，并将注解的内容层设置到这个新的文本层上。</li>
<li>获取你将展示的注解需要放置的柱状图索引。</li>
<li>基于这个索引计算注解的位置，并给使用这个计算位置注解设置 <code>anchorPlotPoint</code> 的值。</li>
<li>最后，将注解添加到图表上。</li>
</ol>
<p>构建并运行。每次当你点按图表中的一个柱体时，该柱体所表示的值就应该正好在其上方弹出来。</p>
<p>棒极了! :]</p>
<p><img src="https://cdn3.raywenderlich.com/wp-content/uploads/2016/04/swiftrates-10.png" alt="Core Plot Tutorial"></p>
<h3 id="隐藏和查找"><a href="#隐藏和查找" class="headerlink" title="隐藏和查找"></a>隐藏和查找</h3><p>这个柱状图看起来很棒，但屏幕最上方的切换开关并没有起什么作用，是时候改动它们了。</p>
<p>首先，需要添加一个帮助方法，把下面这段添加到 <code>switch3Changed(_:)</code> 之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func hideAnnotation(graph: CPTGraph) &#123;</div><div class="line">  guard let plotArea = graph.plotAreaFrame?.plotArea,</div><div class="line">    priceAnnotation = priceAnnotation else &#123;</div><div class="line">      return</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  plotArea.removeAnnotation(priceAnnotation)</div><div class="line">  self.priceAnnotation = nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码首先简单地移除了一个如果存在的注解。</p>
<p>下一步，你希望用户通过切换开关展示一个给定的货币汇率柱状图。</p>
<p>要做到这个功能，用下面这段替换到 <code>switch1Changed(_:)</code>，<code>switch2Changed(_:)</code> 和 <code>switch3Changed(_:)</code> 的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@IBAction func switch1Changed(sender: UISwitch) &#123;</div><div class="line">  let on = sender.on</div><div class="line">  if !on &#123;</div><div class="line">    hideAnnotation(plot1.graph!)</div><div class="line">  &#125;</div><div class="line">  plot1.hidden = !on</div><div class="line">&#125;</div><div class="line"></div><div class="line">@IBAction func switch2Changed(sender: UISwitch) &#123;</div><div class="line">  let on = sender.on</div><div class="line">  if !on &#123;</div><div class="line">    hideAnnotation(plot2.graph!)</div><div class="line">  &#125;</div><div class="line">  plot2.hidden = !on</div><div class="line">&#125;</div><div class="line"></div><div class="line">@IBAction func switch3Changed(sender: UISwitch) &#123;</div><div class="line">  let on = sender.on</div><div class="line">  if !on &#123;</div><div class="line">    hideAnnotation(plot3.graph!)</div><div class="line">  &#125;</div><div class="line">  plot3.hidden = !on</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个逻辑相当简单。如果开关设置了关闭，相关的图和其可见的注解就将被隐藏，而如果设置为开启，则图就会被设置为可见。</p>
<p>构建并运行。现在你可以在图表中随意切换每个柱状图的展示了。教程至此已经完成了很不错的工作！</p>
<p><img src="http://ww4.sinaimg.cn/large/a490147fjw1f5tbq390v7g20fj08sgpr.gif" alt=""></p>
<h2 id="接下来干点啥？"><a href="#接下来干点啥？" class="headerlink" title="接下来干点啥？"></a>接下来干点啥？</h2><p>你可以从<a href="https://cdn1.raywenderlich.com/wp-content/uploads/2016/05/SwiftRates_Final-1.zip" target="_blank" rel="external">这里</a>下载一个已完成的项目。</p>
<p>哇哦，相当有趣！这个教程重点介绍了 Core Plot 的强大功能并希望提示了你该怎么在你自己的 apps 里使用它。</p>
<p>当然还可以参考 <a href="https://github.com/core-plot/core-plot" target="_blank" rel="external">Core Plot</a> 仓库获取更多的信息，包括文档，例子和一些小贴士。</p>
<p>还有，如果你对这个教程有任何的问题或者评论，欢迎加入下面的论坛进行讨论。</p>
<p>祝你有个快乐的绘图过程！</p>
]]></content:encoded>
      
      <comments>http://llp0574.github.io/2016/07/20/core-plot/#disqus_thread</comments>
    </item>
    
    <item>
      <title>node版本管理工具nvm - Mac下安装及使用</title>
      <link>http://llp0574.github.io/2016/02/02/nvm-mac-use/</link>
      <guid>http://llp0574.github.io/2016/02/02/nvm-mac-use/</guid>
      <pubDate>Tue, 02 Feb 2016 13:39:03 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;目前主流的node版本管理工具有两种，nvm和n。&lt;br&gt;两者差异挺大的，具体分析可以参考一下淘宝FED团队的一篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前主流的node版本管理工具有两种，nvm和n。<br>两者差异挺大的，具体分析可以参考一下淘宝FED团队的一篇文章：</p>
<p><a href="http://taobaofed.org/blog/2015/11/17/nvm-or-n/" target="_blank" rel="external">管理 node 版本，选择 nvm 还是 n？</a></p>
<p>总的来说，nvm有点类似于 Python 的 virtualenv 或者 Ruby 的 rvm，每个node版本的模块都会被安装在各自版本的沙箱里面（因此切换版本后模块需重新安装），因此考虑到需要时常对node版本进行切换测试兼容性和一些模块对node版本的限制，我选择了使用nvm作为管理工具，下面就来说说nvm的安装和使用过程。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>一开始，我像往常一样在 <code>oh-my-zsh</code> 中选择了使用 <code>Homebrew</code> 来安装nvm，完成后却发现它被全局安装了，这就造成了后面使用上的一点问题，具体问题可参考<code>Github</code>上的一个<a href="https://github.com/creationix/nvm/issues/855" target="_blank" rel="external">issue</a>。</p>
<p>然后我就又用<code>Homebrew</code>把它给卸掉了，还是决定找找看它的文档，<code>Github</code>上找到<a href="https://github.com/creationix/nvm" target="_blank" rel="external">这里</a>。</p>
<p>清楚看到文档中<code>Installation</code>那一小节倒数第二行有一句<code>Homebrew installation is not supported.</code>，由此可见，没事儿还是要多看看文档。</p>
<p>正式进入安装过程：</p>
<p>我选择了使用<code>curl</code>方式来安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash</div></pre></td></tr></table></figure>
<p>完成后nvm就被安装在了<code>~/.nvm</code>下啦，接下来就需要配一下环境变量了，如果你也使用了<code>zsh</code>的话，就需要在<code>~/.zshrc</code>这个配置文件中配置，否则就找找看<code>~/.bash_profile</code>或者<code>~/.profile</code>吧。</p>
<p>打开<code>~/.zshrc</code>，在最后一行加上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  export NVM_DIR=&quot;$HOME/.nvm&quot;</div><div class="line">  [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm</div><div class="line">```</div></pre></td></tr></table></figure>
<p>这一步的作用是每次新打开一个bash，nvm都会被自动添加到环境变量中了。<br>完成后输入<code>source ~/.zshrc</code>重新启动一下配置。<br>输入<code>nvm</code>可以看到如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">➜  ~  nvm</div><div class="line"></div><div class="line">Node Version Manager</div><div class="line"></div><div class="line">Note: &lt;version&gt; refers to any version-like string nvm understands. This includes:</div><div class="line">  - full or partial version numbers, starting with an optional &quot;v&quot; (0.10, v0.1.2, v1)</div><div class="line">  - default (built-in) aliases: node, stable, unstable, iojs, system</div><div class="line">  - custom aliases you define with `nvm alias foo`</div><div class="line"></div><div class="line">Usage:</div><div class="line">  nvm help                                  Show this message</div><div class="line">  nvm --version                             Print out the latest released version of nvm</div><div class="line">  nvm install [-s] &lt;version&gt;                Download and install a &lt;version&gt;, [-s] from source. Uses .nvmrc if available</div><div class="line">    --reinstall-packages-from=&lt;version&gt;     When installing, reinstall packages installed in &lt;node|iojs|node version number&gt;</div><div class="line">  nvm uninstall &lt;version&gt;                   Uninstall a version</div><div class="line">  nvm use [--silent] &lt;version&gt;              Modify PATH to use &lt;version&gt;. Uses .nvmrc if available</div><div class="line">  nvm exec [--silent] &lt;version&gt; [&lt;command&gt;] Run &lt;command&gt; on &lt;version&gt;. Uses .nvmrc if available</div><div class="line">  nvm run [--silent] &lt;version&gt; [&lt;args&gt;]     Run `node` on &lt;version&gt; with &lt;args&gt; as arguments. Uses .nvmrc if available</div><div class="line">  nvm current                               Display currently activated version</div><div class="line">  nvm ls                                    List installed versions</div><div class="line">  nvm ls &lt;version&gt;                          List versions matching a given description</div><div class="line">  nvm ls-remote                             List remote versions available for install</div><div class="line">  nvm version &lt;version&gt;                     Resolve the given description to a single local version</div><div class="line">  nvm version-remote &lt;version&gt;              Resolve the given description to a single remote version</div><div class="line">  nvm deactivate                            Undo effects of `nvm` on current shell</div><div class="line">  nvm alias [&lt;pattern&gt;]                     Show all aliases beginning with &lt;pattern&gt;</div><div class="line">  nvm alias &lt;name&gt; &lt;version&gt;                Set an alias named &lt;name&gt; pointing to &lt;version&gt;</div><div class="line">  nvm unalias &lt;name&gt;                        Deletes the alias named &lt;name&gt;</div><div class="line">  nvm reinstall-packages &lt;version&gt;          Reinstall global `npm` packages contained in &lt;version&gt; to current version</div><div class="line">  nvm unload                                Unload `nvm` from shell</div><div class="line">  nvm which [&lt;version&gt;]                     Display path to installed node version. Uses .nvmrc if available</div><div class="line"></div><div class="line">Example:</div><div class="line">  nvm install v0.10.32                  Install a specific version number</div><div class="line">  nvm use 0.10                          Use the latest available 0.10.x release</div><div class="line">  nvm run 0.10.32 app.js                Run app.js using node v0.10.32</div><div class="line">  nvm exec 0.10.32 node app.js          Run `node app.js` with the PATH pointing to node v0.10.32</div><div class="line">  nvm alias default 0.10.32             Set default node version on a shell</div><div class="line"></div><div class="line">Note:</div><div class="line">  to remove, delete, or uninstall nvm - just remove the `$NVM_DIR` folder (usually `~/.nvm`)</div></pre></td></tr></table></figure>
<p>至此，nvm的安装就算是告一段落了，下面我们就来看一下如何使用它来对node版本进行切换使用。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>其实，上述最后一步打印出的信息已经可以清楚看到nvm的全部命令。<br>各项命令的详细用法及含义可参考上文提到的<a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm文档</a>。</p>
<p>接下来就轮到安装我们的主角node大哥了。</p>
<p>首先我们可以使用<code>nvm ls-remote</code>看一下node有哪些版本可以安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜  ~  nvm ls-remote</div><div class="line">            v0.1.14</div><div class="line">            v0.1.15</div><div class="line">            v0.1.16</div><div class="line">            ...</div></pre></td></tr></table></figure>
<blockquote>
<p>Note：由于在写文章的时候网络有问题，无法展示所有结果出来，上面代码示意一下，正确情况下会显示非常多版本出来，大家都知道node更新速度非常非常快。</p>
</blockquote>
<p>我常用的node版本是4.1.0，因此首先安装这个版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ nvm install v4.1.0</div><div class="line">######################################################################## 100.0%</div><div class="line"></div><div class="line">Now using node v4.1.0</div></pre></td></tr></table></figure>
<p>同时安装一下最新版来测试nvm的版本管理功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ nvm install v5.5.0</div><div class="line">######################################################################## 100.0%</div><div class="line"></div><div class="line">Now using node v5.5.0</div></pre></td></tr></table></figure>
<h3 id="使用nvm轻松切换node版本"><a href="#使用nvm轻松切换node版本" class="headerlink" title="使用nvm轻松切换node版本"></a>使用nvm轻松切换node版本</h3><p>在介绍使用方法前，简单说明一下nvm的工作原理：</p>
<p>按照我上述安装方法的话，nvm会将各个版本的node安装在<code>~/.nvm/versions/node</code>目录下，我们可以打开这个目录看看有些什么东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  ~  ls -a ~/.nvm/versions/node</div><div class="line">.      ..     v4.1.0 v5.5.0</div></pre></td></tr></table></figure>
<p>事实上<code>v4.1.0</code>和<code>v5.5.0</code>这两个目录分别存放node的binary档，nvm会在<code>$PATH</code>前面安插指定版本的目录，透过这种方式在使用node命令时就会用指定版本的node来运行了。</p>
<p>可以确认实际的<code>$PATH</code>看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  ~  echo $PATH</div><div class="line">/Users/***/.nvm/versions/node/v5.5.0/bin:...</div></pre></td></tr></table></figure>
<p>由于刚刚我们通过nvm安装node，会自动把最后安装的版本设为当前使用的版本，因此上述路径结尾会是<code>.../v5.5.0/bin</code>（还可通过<code>nvm ls</code>命令查看当前已安装的所有node版本）。</p>
<p>接下来我们可以使用<code>nvm use &lt;version&gt;</code>切换版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜  ~  nvm use v4.1.0</div><div class="line">Now using node v4.1.0 (npm v2.14.3)</div><div class="line">➜  ~  node -v</div><div class="line">v4.1.0</div><div class="line">➜  ~  nvm use v5.5.0</div><div class="line">Now using node v5.5.0 (npm v3.3.12)</div><div class="line">➜  ~  node -v</div><div class="line">v5.5.0</div></pre></td></tr></table></figure>
<p>轻轻松松完成切换！</p>
<p>不过问题来了，这时如果你新打开一个bash，输入<code>nvm current</code>会发现显示为<code>null</code>，这是因为使用<code>nvm use</code>命令只会在当前bash里生效，重新打开一个bash你会发现<code>$PATH</code>的值已经不包含刚才的node目录了，要解决这个问题也很简单，使用<code>nvm alias default &lt;version&gt;</code>命令来指定一个默认的node版本就ok了，这里我使用了<code>v4.1.0</code>作为默认版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  ~  nvm alias default v4.1.0</div><div class="line">default -&gt; v4.1.0</div></pre></td></tr></table></figure>
<p>此时再打开一个bash输入<code>nvm current</code>就会显示为<code>v4.1.0</code>了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上为我在安装nvm的过程中通过各种资料总结出来的一套简单教程，欢迎大家分享交流！</p>
]]></content:encoded>
      
      <comments>http://llp0574.github.io/2016/02/02/nvm-mac-use/#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用AngularJS构建应用时遇到的问题及解决方案（版本为1.3.9）</title>
      <link>http://llp0574.github.io/2016/01/16/angular-js-problem-collections/</link>
      <guid>http://llp0574.github.io/2016/01/16/angular-js-problem-collections/</guid>
      <pubDate>Sat, 16 Jan 2016 13:20:52 GMT</pubDate>
      <description>
      
        &lt;p&gt;最近在公司使用AngularJS（1.3.9）完成了一个项目，在此记录一下过程中遇到的问题及解决方案。&lt;/p&gt;
&lt;h2 id=&quot;使用-http服务发送ajax请求时后端无法判断请求是XMLHttpRequest&quot;&gt;&lt;a href=&quot;#使用-http服务发送ajax请求时后端
      
      </description>
      
      <content:encoded><![CDATA[<p>最近在公司使用AngularJS（1.3.9）完成了一个项目，在此记录一下过程中遇到的问题及解决方案。</p>
<h2 id="使用-http服务发送ajax请求时后端无法判断请求是XMLHttpRequest"><a href="#使用-http服务发送ajax请求时后端无法判断请求是XMLHttpRequest" class="headerlink" title="使用$http服务发送ajax请求时后端无法判断请求是XMLHttpRequest"></a>使用<code>$http</code>服务发送ajax请求时后端无法判断请求是<code>XMLHttpRequest</code></h2><p><strong>问题及场景</strong>：<br>有时候后端会读取请求中<code>header</code>的<code>X-Requested-With</code>字段判断前端的请求是否为异步请求<code>XMLHttpRequest</code>，在使用<code>$http</code>服务发送请求时后端却判断为<code>false</code>。</p>
<p><strong>原因</strong>：<br><code>&#39;X-Requested-With&#39; : &#39;XMLHttpRequest&#39;</code>并不属于标准的<code>header</code>内容，因此Angular不会在<code>header</code>中默认设置该字段。</p>
<p><strong>解决方案</strong>：<br>手动在<code>$httpProvider</code>中设置该字段，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$httpProvider.defaults.headers.common[&apos;X-Requested-With&apos;] = &apos;XMLHttpRequest&apos;;</div></pre></td></tr></table></figure>
<p><strong>note</strong>:<br>可以创建一个公用服务，在配置方法做这个修改，公用服务注入到每个module里就一劳永逸了。</p>
<h2 id="使用-http-post-方法参数类型不正确"><a href="#使用-http-post-方法参数类型不正确" class="headerlink" title="使用$http.post()方法参数类型不正确"></a>使用<code>$http.post()</code>方法参数类型不正确</h2><p><strong>问题及场景</strong>：<br>在angular中，使用<code>$http.post()</code>方法提交数据时，发现所带参数并非<code>Form Data</code>，而是JSON对象，导致服务器无法使用一般方法正确获取参数，而使用jQuery的<code>$.post()</code>方法却可以正确获取。</p>
<p><strong>原因</strong>：<br>两者的post对header的处理有所不同，jQuery会把作为JSON对象的myData序列化，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var myData = &#123; a : 1, b : 2 &#125;;</div><div class="line">// jQuery在post数据之前会把myData转换成字符串：&quot;a=1&amp;b=2&quot;</div></pre></td></tr></table></figure>
<p>angular显然没做这个处理。</p>
<p><strong>解决方案</strong>：<br>修改Angular的<code>$httpProvider</code>的默认处理，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$httpProvider.defaults.transformRequest = function(obj)&#123;</div><div class="line">    var str = [];</div><div class="line">    for(var p in obj) &#123;</div><div class="line">        str.push(encodeURIComponent(p) + &apos;=&apos; + encodeURIComponent(obj[p]));</div><div class="line">    &#125;</div><div class="line">    return str.join(&quot;&amp;&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">$httpProvider.defaults.headers.post = &#123;</div><div class="line">    &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>note</strong>:<br>同样应该在公用服务中做此修改。</p>
<h2 id="调用-scope-apply-fn-更新视图时报错-rootScope-inprog"><a href="#调用-scope-apply-fn-更新视图时报错-rootScope-inprog" class="headerlink" title="调用$scope.$apply(fn)更新视图时报错$rootScope:inprog"></a>调用<code>$scope.$apply(fn)</code>更新视图时报错<code>$rootScope:inprog</code></h2><p><strong>问题及场景</strong>：<br>在更新$scope上的model数据时，如果是在<code>digest</code>监听外，会发现视图并没有自动更新，于是手动调用<code>$scope.$apply(fn)</code>方法通知视图进行更新，却发现有时候会报错<code>$rootScope:inprog</code>。</p>
<p><strong>原因</strong>：<br>该错误原因是在进程当中<code>$scope.$apply(fn)</code>正在执行，不能在此基础上重复调用该方法。</p>
<p><strong>解决方案</strong>：<br>可以在调用该方法时做一个安全检测，封装代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$scope.safeApply = function(fn) &#123;</div><div class="line">    var phase = this.$root.$$phase;</div><div class="line">    if (phase === &apos;$apply&apos; || phase === &apos;$digest&apos;) &#123;</div><div class="line">        if (fn &amp;&amp; (typeof(fn) === &apos;function&apos;)) &#123;</div><div class="line">            fn();</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        this.$apply(fn);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>note</strong>:<br><code>$$phase</code>变量是<code>scope</code>中的一个内部属性，如果为<code>null</code>或者<code>undefined</code>则说明进程中没有<code>$apply</code>方法在运行，则可以直接调用，否则直接执行入参方法。</p>
<h2 id="添加统一拦截器对ajax的请求或返回做处理"><a href="#添加统一拦截器对ajax的请求或返回做处理" class="headerlink" title="添加统一拦截器对ajax的请求或返回做处理"></a>添加统一拦截器对ajax的请求或返回做处理</h2><p><strong>问题及场景</strong>：<br>我遇到的场景是在发送异步请求时，后端会先判断用户是否已经登录，如果未登录则会在<code>response</code>的<code>header</code>中添加一个<code>redirecturl</code>字段，前端读取该字段控制页面跳转到该url，我首先想到的解决方案就是前端需要做一个统一拦截器，对所有异步请求的<code>response</code>进行拦截。</p>
<p><strong>解决方案</strong>：<br>通过看Angular中<code>$httpProvider</code>部分的源码注释，发现了拦截器的几种写法，我选择的写法源码注释如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">*   // register the interceptor as a service</div><div class="line">*   $provide.factory(&apos;myHttpInterceptor&apos;, function($q, dependency1, dependency2) &#123;</div><div class="line">*     return &#123;</div><div class="line">*       // optional method</div><div class="line">*       &apos;request&apos;: function(config) &#123;</div><div class="line">*         // do something on success</div><div class="line">*         return config;</div><div class="line">*       &#125;,</div><div class="line">*</div><div class="line">*       // optional method</div><div class="line">*      &apos;requestError&apos;: function(rejection) &#123;</div><div class="line">*         // do something on error</div><div class="line">*         if (canRecover(rejection)) &#123;</div><div class="line">*           return responseOrNewPromise</div><div class="line">*         &#125;</div><div class="line">*         return $q.reject(rejection);</div><div class="line">*       &#125;,</div><div class="line">*       // optional method</div><div class="line">*       &apos;response&apos;: function(response) &#123;</div><div class="line">*         // do something on success</div><div class="line">*         return response;</div><div class="line">*       &#125;,</div><div class="line">*</div><div class="line">*       // optional method</div><div class="line">*      &apos;responseError&apos;: function(rejection) &#123;</div><div class="line">*         // do something on error</div><div class="line">*         if (canRecover(rejection)) &#123;</div><div class="line">*           return responseOrNewPromise</div><div class="line">*         &#125;</div><div class="line">*         return $q.reject(rejection);</div><div class="line">*       &#125;</div><div class="line">*     &#125;;</div><div class="line">*   &#125;);</div><div class="line">*   $httpProvider.interceptors.push(&apos;myHttpInterceptor&apos;);</div></pre></td></tr></table></figure>
<p>我拦截<code>response</code>的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">commonService.factory(&apos;redirectInterceptor&apos;, function()&#123;</div><div class="line">    return &#123;</div><div class="line">        &apos;response&apos;: function(response) &#123;</div><div class="line">            if(response.headers().redirecturl) &#123;</div><div class="line">                window.location.href = response.headers().redirecturl;</div><div class="line">            &#125;</div><div class="line">            return response;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">$httpProvider.interceptors.push(&apos;redirectInterceptor&apos;);</div></pre></td></tr></table></figure>
<p><strong>note</strong>：<br>最后一行表示将该拦截器登记到<code>$httpProvider</code>的拦截器中，同样应该写在公用服务的配置方法当中。</p>
<h2 id="controller之间的通信问题"><a href="#controller之间的通信问题" class="headerlink" title="controller之间的通信问题"></a><code>controller</code>之间的通信问题</h2><p><strong>问题及场景</strong>：<br>当有两个视图分别由两个<code>controller</code>控制时，其中一个视图发生变化，需通知另一个视图产生了此变化。</p>
<p><strong>解决方案</strong>：<br>总的来说，Angular中控制器通信有三种处理方法：</p>
<ul>
<li>利用作用域继承的方式 即子控制器继承父控制器中的内容；</li>
<li>基于事件的方式 即<code>$on</code>,<code>$emit</code>,<code>$boardcast</code>这三种方法；</li>
<li>服务方式 写一个服务的单例然后通过注入来使用。</li>
</ul>
<p>我选择了最后一种方法，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//JS</div><div class="line">var app = angular.module(&apos;myApp&apos;, []);</div><div class="line">app.factory(&apos;instance&apos;, function()&#123;</div><div class="line">    return &#123;&#125;;</div><div class="line">&#125;);</div><div class="line">app.controller(&apos;MainCtrl&apos;, function($scope, instance) &#123;</div><div class="line">    $scope.change = function() &#123;</div><div class="line">    instance.name = $scope.test;</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line">app.controller(&apos;sideCtrl&apos;, function($scope, instance) &#123;</div><div class="line">    $scope.add = function() &#123;</div><div class="line">        $scope.name = instance.name;</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//html</div><div class="line">&lt;div ng-controller=&quot;MainCtrl&quot;&gt;</div><div class="line">    &lt;input type=&quot;text&quot; ng-model=&quot;test&quot; /&gt;</div><div class="line">    &lt;div ng-click=&quot;change()&quot;&gt;click me&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div ng-controller=&quot;sideCtrl&quot;&gt;</div><div class="line">    &lt;div ng-click=&quot;add()&quot;&gt;my name &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><strong>note</strong>:<br>在Angular中服务是一个单例，所以在服务中生成一个对象，该对象就可以利用依赖注入的方式在所有的控制器中共享。<br>如果不是通过点击产生变化，还可结合<code>$scope.$watch()</code>方法来进行通信。<br>其他两种方法可参考站内文章：<a href="https://segmentfault.com/a/1190000000639592" target="_blank" rel="external">AngularJS控制器controller如何通信？</a></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上为我在编写一个angular应用时遇到的问题及解决方案，记录并分享出来，欢迎大家指正！</p>
]]></content:encoded>
      
      <comments>http://llp0574.github.io/2016/01/16/angular-js-problem-collections/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hello Hexo</title>
      <link>http://llp0574.github.io/2016/01/15/hello-hexo/</link>
      <guid>http://llp0574.github.io/2016/01/15/hello-hexo/</guid>
      <pubDate>Fri, 15 Jan 2016 13:20:52 GMT</pubDate>
      <description>
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
      </description>
      
      <content:encoded><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content:encoded>
      
      <comments>http://llp0574.github.io/2016/01/15/hello-hexo/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
